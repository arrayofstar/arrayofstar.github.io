<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>PyCaret-自动机器学习框架 | Dreamstar</title><meta name="author" content="dreamstar"><meta name="copyright" content="dreamstar"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SPWLA_group-自动机器学习 作者：CSY、Dreamstar		校对：Dreamstar  参考链接：https:&#x2F;&#x2F;pycaret.gitbook.io&#x2F;docs&#x2F;  本教程涵盖了整个AutoML过程，包含数据获取、预处理、模型训练、超参数调优、模型预测、保存与部署，以备未来随时使用与查看。 以下命令是PyCaret中主流程的函数，这些命令是自然构造的，并且非常直观易记，例如： set">
<meta property="og:type" content="article">
<meta property="og:title" content="PyCaret-自动机器学习框架">
<meta property="og:url" content="http://dreamstar.top/2024/04/25/1.MachineLearning/AutoML/PyCaret/index.html">
<meta property="og:site_name" content="Dreamstar">
<meta property="og:description" content="SPWLA_group-自动机器学习 作者：CSY、Dreamstar		校对：Dreamstar  参考链接：https:&#x2F;&#x2F;pycaret.gitbook.io&#x2F;docs&#x2F;  本教程涵盖了整个AutoML过程，包含数据获取、预处理、模型训练、超参数调优、模型预测、保存与部署，以备未来随时使用与查看。 以下命令是PyCaret中主流程的函数，这些命令是自然构造的，并且非常直观易记，例如： set">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://dreamstar.top/img/for_post/pycaret.svg">
<meta property="article:published_time" content="2024-04-25T14:00:00.000Z">
<meta property="article:modified_time" content="2024-05-15T14:00:00.000Z">
<meta property="article:author" content="dreamstar">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://dreamstar.top/img/for_post/pycaret.svg"><link rel="shortcut icon" href="/img/favicon-mf.ico"><link rel="canonical" href="http://dreamstar.top/2024/04/25/1.MachineLearning/AutoML/PyCaret/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PyCaret-自动机器学习框架',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-15 22:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/for_post/pycaret.svg')"><nav id="nav"><span id="blog-info"><a href="/" title="Dreamstar"><img class="site-icon" src="/img/favicon-mf.ico"/><span class="site-name">Dreamstar</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">PyCaret-自动机器学习框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-25T14:00:00.000Z" title="发表于 2024-04-25 22:00:00">2024-04-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-15T14:00:00.000Z" title="更新于 2024-05-15 22:00:00">2024-05-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AutoML/">AutoML</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="PyCaret-自动机器学习框架"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="SPWLA-group-自动机器学习"><a href="#SPWLA-group-自动机器学习" class="headerlink" title="SPWLA_group-自动机器学习"></a>SPWLA_group-自动机器学习</h1><blockquote>
<p>作者：CSY、Dreamstar		校对：Dreamstar</p>
<p> 参考链接：<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/">https://pycaret.gitbook.io/docs/</a></p>
</blockquote>
<p>本教程涵盖了整个AutoML过程，包含数据获取、预处理、模型训练、超参数调优、模型预测、保存与部署，以备未来随时使用与查看。</p>
<p>以下命令是PyCaret中主流程的函数，这些命令是自然构造的，并且非常直观易记，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setup()  <span class="comment"># 初始化</span></span><br><span class="line">create_model()  <span class="comment"># 创建模型</span></span><br><span class="line">compare_models()  <span class="comment"># 比较模型</span></span><br><span class="line">tune_model()  <span class="comment"># 微调模型</span></span><br><span class="line">plot_model()  <span class="comment"># 绘图</span></span><br><span class="line">evaluate_model()  <span class="comment"># 评估模型</span></span><br><span class="line">predict_model()  <span class="comment"># 模型预测</span></span><br></pre></td></tr></table></figure>

<p>PyCaret的全局流程如下：</p>
<p><strong>Setup</strong> ➡️ <strong>Compare Models</strong> ➡️ <strong>Analyze Model</strong> ➡️ <strong>Prediction</strong> ➡️ <strong>Save Model</strong></p>


<h2 id="Pycaret简介"><a href="#Pycaret简介" class="headerlink" title="Pycaret简介"></a>Pycaret简介</h2><p>Pycaret是一个用于快速原型设计和自动化机器学习流程的Python开源库，旨在简化机器学习任务的常见工作流程，如数据预处理、特征工程、模型选择、调参和模型部署。</p>
<p>与其他开源机器学习库相比，PyCaret是一个替代的低代码库，可以用几行代码替换数百行代码。这使得实验速度和效率呈指数级增长。PyCaret本质上是围绕几个机器学习库和框架的Python包装器，如scikit-learn、XGBoost、LightGBM、CatBoost、spaCy、Optuna、Hyperopt、Ray等。</p>
<p>以下是Pycaret的一些主要功能和特点：</p>
<ol>
<li>自动化：Pycaret提供了一套自动化工具，可以自动处理数据预处理、特征选择、特征工程和模型选择等任务。它根据数据的类型自动选择合适的预处理方法，并提供了一系列自动化算法来选择最佳模型。</li>
<li>多模型比较：Pycaret支持比较多个机器学习模型的性能。它为用户提供了一个简单的接口，可以快速训练和比较多个模型，并生成模型性能指标的可视化图表。</li>
<li>模型调参：Pycaret提供了一套用于模型调参的工具。它可以自动搜索参数空间，并使用交叉验证方法选择最佳的参数组合。</li>
<li>模型解释性：Pycaret提供了一些用于解释模型结果的工具，如特征重要性图表和SHAP值分析。这些工具可以帮助用户理解模型的预测能力和特征的影响程度。</li>
<li>模型部署：Pycaret支持将训练好的模型导出为独立的Python代码，以便在生产环境中进行部署和集成。</li>
</ol>
<p>总之，Pycaret是一个强大的机器学习库，提供了许多方便而强大的工具，可以帮助数据科学家和机器学习工程师快速构建和部署机器学习模型。无论是初学者还是经验丰富的专业人士，都可以通过使用Pycaret来加速机器学习任务的开发和迭代过程。</p>
<blockquote>
<p>相关库的文件和其他相关资料：<a href="https://link.zhihu.com/?target=https://pycaret.org/">https://pycaret.org/</a> 。</p>
<p>需要安装pycaret的话，请运行以下命令：<code>!pip install pycaret</code>。</p>
</blockquote>
<h2 id="Pycaret安装"><a href="#Pycaret安装" class="headerlink" title="Pycaret安装"></a>Pycaret安装</h2><p>PyCaret的默认安装不会自动安装所有可选的依赖项。根据使用情况，您可能对一个或多个附加功能感兴趣：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># install simple version</span><br><span class="line">pip install pycaret`</span><br><span class="line"></span><br><span class="line"># install analysis extras</span><br><span class="line">pip install pycaret[analysis]</span><br><span class="line"></span><br><span class="line"># models extras</span><br><span class="line">pip install pycaret[models]</span><br><span class="line"></span><br><span class="line"># install tuner extras</span><br><span class="line">pip install pycaret[tuner]</span><br><span class="line"></span><br><span class="line"># install mlops extras</span><br><span class="line">pip install pycaret[mlops]</span><br><span class="line"></span><br><span class="line"># install parallel extras</span><br><span class="line">pip install pycaret[parallel]</span><br><span class="line"></span><br><span class="line"># install test extras</span><br><span class="line">pip install pycaret[test]</span><br><span class="line"></span><br><span class="line"># install multiple extras together</span><br><span class="line">pip install pycaret[analysis,models]</span><br><span class="line"></span><br><span class="line"># install full version</span><br><span class="line">pip install pycaret[full]</span><br></pre></td></tr></table></figure>

<p><strong>对于google colab用户</strong>：如果需要在google colab中运行此笔记本，请在笔记本顶部运行以下代码以显示交互式图像。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">from pycaret.utils import enable_colab</span><br><span class="line">enable_colab()</span><br></pre></td></tr></table></figure>

<h2 id="PyCaret模块划分"><a href="#PyCaret模块划分" class="headerlink" title="PyCaret模块划分"></a>PyCaret模块划分</h2><p>Pycaret模块根据我们要执行的任务进行划分，这些模块代表了不种类型的学习任务(有监督的或无监督的)。</p>
<p><strong>有监督ML(Supervised ML)</strong></p>
<ul>
<li>分类(Classification)</li>
</ul>
<p>PyCaret的分类模块是一个有监督的机器学习模块，用于将元素分组。</p>
<p>目标是预测离散和无序的分类类标签。一些常见的用例包括预测客户违约（是或否）、预测客户流失（客户将离开或留下）、发现的疾病（阳性或阴性）。</p>
<p>此模块可用于二分类或多分类问题。</p>
<ul>
<li>回归(Regression)</li>
</ul>
<p>PyCaret的回归模块是一个有监督的机器学习模块，用于估计因变量（通常被称为“结果变量”或“目标”）和一个或多个自变量（通常被称作“特征”、“预测因子”或“协变量”）之间的关系。</p>
<p>回归的目的是预测连续值，如预测销售额、预测数量、预测温度等。</p>
<p><strong>无监督ML(Unsupervised ML)</strong></p>
<ul>
<li>聚类(Clustering)</li>
</ul>
<p>PyCaret的聚类模块是一个无监督的机器学习模块，它执行对一组对象进行分组的任务，使同一组（也称为聚类）中的对象彼此之间比其他组中的对象更相似。</p>
<ul>
<li>异常检测(Anomaly Detection)</li>
</ul>
<p>PyCaret的异常检测模块用于识别数据中不符合正常模式的数据点(如罕见项、事件或观察结果)。通常，异常项目会转化为某种问题，如银行欺诈、结构缺陷、医疗诊断。</p>
<p><strong>时间序列(Time Series)</strong></p>
<p>PyCaret时间序列模块是使用机器学习和经典统计技术分析和预测时间序列数据的强大工具。该模块支持多种预测方法，如ARIMA、Prophet和LSTM。它还提供了各种功能来处理缺失值、时间序列分解和数据可视化。</p>


<h1 id="PyCaret模块"><a href="#PyCaret模块" class="headerlink" title="PyCaret模块"></a>PyCaret模块</h1><h2 id="1-获取数据"><a href="#1-获取数据" class="headerlink" title="1. 获取数据"></a>1. 获取数据</h2>

<p>获取数据是进行数据分析的第一步，PyCaret可以通过两种途径进行数据的获取。</p>
<p><strong>(1) 尝试从GitHub“address”中的文件夹读取数据集</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看数据集的索引</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">all_datasets=get_data(<span class="string">&#x27;index&#x27;</span>,address=<span class="string">&#x27;https://gitee.com/IncubatorShokuhou/pycaret/raw/master/datasets/&#x27;</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载并查看数据集</span></span><br><span class="line">bike_data= get_data(<span class="string">&#x27;bike&#x27;</span>,address=<span class="string">&#x27;https://gitee.com/IncubatorShokuhou/pycaret/raw/master/datasets/&#x27;</span>)  <span class="comment"># 第45个</span></span><br></pre></td></tr></table></figure>



<p><strong>(2) 从本地文件夹读取数据集</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用pandas加载数据</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;aligned_well_01_1_strech_1.csv&#x27;</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>



<h2 id="2-Initialize-设置PyCaret环境-setup"><a href="#2-Initialize-设置PyCaret环境-setup" class="headerlink" title="2. Initialize-设置PyCaret环境-setup"></a>2. Initialize-设置PyCaret环境-<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/initialize#setting-up-environment">setup</a></h2>

<p><code>setup()</code>函数的作用是：初始化pycaret的实验环境，并创建转换管道，为建模和部署准备数据。</p>
<p>在pycaret中执行任何其他函数之前必须调用<code>setup()</code>。它需要两个必需的参数：数据(pandas dataframe-data)和目标(目标列的名称-target)。大部分配置可使用默认值自动完成，但有些参数可以手动设置。例如：</p>
<ul>
<li>默认的分割比是7:3，但是可以用“train_size”来更改，默认0.7；</li>
<li>K折叠交叉验证，默认设置为10；</li>
<li>“session_id”是我们经典的“random_state”，即随机种子。</li>
</ul>
<p>PyCaret 3.0中有两个API。您可以根据自己的喜好选择其中一个。功能和实验结果是一致的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Functional API - 函数接口</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>, session_id = <span class="number">123</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># OOP API -  面向对象接口</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> ClassificationExperiment</span><br><span class="line">clf1 = ClassificationExperiment()</span><br><span class="line">clf1.setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>, session_id = <span class="number">123</span>)</span><br></pre></td></tr></table></figure>

<p>设置环境：(以回归为例)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pycaret.regression <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_setup = setup(data=df, <span class="comment"># 训练数据集</span></span><br><span class="line">                    target=<span class="string">&#x27;RHOB_pred&#x27;</span>, <span class="comment"># 预测目标</span></span><br><span class="line">            ignore_features=[<span class="string">&#x27;DEPT&#x27;</span>,<span class="string">&#x27;RHOB&#x27;</span>, <span class="string">&#x27;RHOB_dept_pred&#x27;</span>, <span class="string">&#x27;NPHI_dept_pred&#x27;</span>, <span class="string">&#x27;RD_dept_pred&#x27;</span>, <span class="string">&#x27;wellnum&#x27;</span>,<span class="string">&#x27;NPHI_pred&#x27;</span>,<span class="string">&#x27;RD_pred&#x27;</span>],  <span class="comment"># 需要忽视的特征</span></span><br><span class="line">            keep_features=[<span class="string">&#x27;GR&#x27;</span>,<span class="string">&#x27;NPHI&#x27;</span>,<span class="string">&#x27;RD&#x27;</span>],  <span class="comment"># 选择特征</span></span><br><span class="line">            session_id=<span class="number">42</span>,  <span class="comment"># 随机数种子</span></span><br><span class="line">            train_size=<span class="number">0.8</span>,  <span class="comment"># 划分训练集测试集</span></span><br><span class="line">            normalize=<span class="literal">True</span>,  <span class="comment"># 标准化，默认为zscore，可以通过normalize_method设置[minmax,maxabs,robust]</span></span><br><span class="line">            use_gpu=<span class="literal">True</span>,</span><br><span class="line">            remove_outliers=<span class="literal">True</span>,  <span class="comment"># 默认使用隔离森林删除数据中的异常值，可以通过outliers_method来设置删除异常值的方法</span></span><br><span class="line">            fold=<span class="number">10</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure>



<p>以下是针对Pycaret中<code>setup()</code>模块输出的解释：</p>
<ol>
<li>Session id（会话ID）：用于标识Pycaret会话的唯一标识符。</li>
<li>Target（目标）：指定机器学习任务中的目标变量（预测变量）。在分类问题中，它通常是类别标签；在回归问题中，它通常是连续的数值。</li>
<li>Target type（目标类型）：目标变量的类型，可以是分类（classification）或回归（regression）。</li>
<li>Original data shape（原始数据形状）：原始数据集的维度信息，指示数据集的行数和列数。</li>
<li>Transformed data shape（转换后的数据形状）：经过预处理和转换后的数据集的维度信息。</li>
<li>Transformed train set shape（转换后的训练集形状）：经过预处理和转换后的训练集的维度信息。</li>
<li>Transformed test set shape（转换后的测试集形状）：经过预处理和转换后的测试集的维度信息。</li>
<li>Ignore features（忽略特征）：需要在机器学习任务中忽略的特征（列）的数量。</li>
<li>Numeric features（数值特征）：数值型特征（列）的数量，用于指定数据集中的数值型变量。</li>
<li>Keep features（保留特征）：需要在机器学习任务中保留的特征（列）的数量。</li>
<li>Preprocess（预处理）：指定在训练模型之前进行的数据预处理步骤。</li>
<li>Imputation type（缺失值填补类型）：用于处理数据集中缺失值的方法类型。</li>
<li>Numeric imputation（数值型特征的填补方式）：用于填补数值型特征中缺失值的方法。</li>
<li>Categorical imputation（分类特征的填补方式）：用于填补分类特征中缺失值的方法。</li>
<li>Normalize（归一化）：指定是否对数据进行归一化处理。</li>
<li>Normalize method（归一化方法）：用于归一化数据的方法。</li>
<li>Fold Generator（折叠生成器）：用于生成交叉验证折叠的方法。</li>
<li>Fold Number（折叠数量）：指定交叉验证的折叠数量。</li>
<li>CPU Jobs（CPU任务数）：指定在Pycaret中执行的CPU任务的数量。</li>
<li>Use GPU（使用GPU）：指定是否使用GPU加速进行模型训练和推断。</li>
<li>Log Experiment（记录实验）：指定是否记录实验的详细信息和结果。</li>
<li>Experiment Name（实验名称）：用于标识实验的名称。</li>
<li>USI（用户定义的标识）：用于跟踪和标识特定实验的用户自定义标识符。</li>
</ol>
<h3 id="2-1-数据准备-缺失值处理-Missing-Values"><a href="#2-1-数据准备-缺失值处理-Missing-Values" class="headerlink" title="2.1 数据准备 - 缺失值处理(Missing Values)"></a>2.1 数据准备 - 缺失值处理(Missing Values)</h3><p>由于各种原因，数据集中可能有缺失的值或空记录，通常为空白或<code>NaN</code>。大多数机器学习算法无法处理缺失或空白的值。删除缺失值的样本是有时使用的一种基本策略，但这会丢失可能有价值的数据和相关信息或模式。更好的策略是对缺失值进行填补。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>imputation_type: string, default &#x3D; ‘simple’</strong></p>
<p>要使用的插补类型。它可以是<code>simple</code>，也可以是<code>iterative</code>。如果是<code>None</code>，则不进行缺失值的插补。</p>
</li>
<li><p><strong>numeric_imputation: int, float, or string, default &#x3D; ‘mean’</strong></p>
<p>数值数据列的输入策略。当<code>imputation_type=iterative</code>时忽略。有以下选择：</p>
<ul>
<li>drop: 丢弃包含缺失值的行</li>
<li>mean: 使用当前列的平均值</li>
<li>median: 使用当前列的中位数</li>
<li>mode: 使用当前列的高频值</li>
<li>knn: 使用K近邻的方法进行补充</li>
<li>int or float: 使用所提供的值进行补充</li>
</ul>
</li>
<li><p><strong>categorical_imputation: string, default &#x3D; ‘mode’</strong></p>
<p>类别数据列的推测策略。当<code>imputation_type=iterative</code>时忽略。有以下选择：</p>
<ul>
<li>drop: 丢弃包含缺失值的行</li>
<li>mode: 使用当前列的高频值</li>
<li>str: 使用所提供的字符进行补充</li>
</ul>
</li>
<li><p><strong>iterative_imputation_iters: int, default &#x3D; 5</strong></p>
<p>迭代次数。当<code>imputation_type=simple</code>时忽略。</p>
</li>
<li><p><strong>numeric_iterative_imputer: str or sklearn estimator, default &#x3D; ‘lightgbm’</strong></p>
<p>用于对数值数据特征中缺失值进行迭代插补的回归器。如果无，则使用LGB分类器。当<code>imputation_type=simple</code>时忽略。’</p>
</li>
<li><p><strong>categorical_iterative_imputer: str or sklearn estimator, default &#x3D; ‘lightgbm’</strong></p>
<p>用于对分类特征中的缺失值进行迭代插补的回归器。如果无，则使用LGB分类器。当<code>imputation_type=simple</code>时忽略。</p>
</li>
</ul>
<blockquote>
<p>可用的方法包含：et、rf、catboost、lightgbm、knn、simple</p>
</blockquote>
<p><strong>简单估算器与迭代估算器的比较</strong></p>


<h3 id="2-2-数据准备-数据类型-Data-Types"><a href="#2-2-数据准备-数据类型-Data-Types" class="headerlink" title="2.2 数据准备 - 数据类型(Data Types)"></a>2.2 数据准备 - 数据类型(Data Types)</h3><p>数据集中的每个特征都有一个相关的数据类型，如数字、分类或日期时间。PyCaret的推理算法自动检测每个特征的数据类型。但是，有时PyCaret推断的数据类型是不正确的。确保数据类型正确非常重要，因为几个下游流程取决于特征的数据类型。一个例子可能是数据集中<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/preprocessing/data-preparation#missing-values">缺失值</a>的数字和分类特征的填补方式不同。若要覆盖推断的数据类型，可以在设置函数中使用<code>numeric_features</code>、<code>categorical_features</code>和<code>date_features</code>参数。也可以使用<code>ignore_features</code>忽略某些特征以进行模型训练。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>numeric_features: list of string, default &#x3D; None</strong></p>
<p>如果推断出的数据类型不正确，则可以使用<code>numeric_features</code>来覆盖推断的数据类型。</p>
</li>
<li><p><strong>categorical_features: list of string, default &#x3D; None</strong></p>
<p>如果推断出的数据类型不正确，则可以使用<code>categorical_features</code>来覆盖推断的数据类型。</p>
</li>
<li><p><strong>date_features: list of string, default &#x3D; None</strong></p>
<p>如果数据的<code>Datetime</code>列在运行安装程序时未自动推断，则可以使用<code>date_features</code>强制数据类型。它可以处理多个日期列。建模中不使用与日期时间相关的功能。相反，在模型训练过程中，执行特征提取并忽略原始<code>Datetime</code>列。如果<code>Datetime</code>列包含时间戳，则还将提取与时间相关的特征。</p>
</li>
<li><p><strong>create_date_columns: list of str, default &#x3D; [“day”, “month”, “year”]</strong></p>
<p>要根据日期功能创建的列。请注意，已创建的零差异特征（例如，仅包含日期的列中的小时数）将被忽略。允许的值是<code>pandas.Series.dt</code>的日期时间属性。特征的日期时间格式是根据第一个非NaN值自动推断的。</p>
</li>
<li><p><strong>text_features: list of str, default &#x3D; None</strong></p>
<p>包含文本语料库的列名。如果“无”，则不选择任何文本功能。</p>
</li>
<li><p><strong>text_features_method: str, default &#x3D; ‘tf-idf’</strong></p>
<p>用于在数据集中嵌入文本功能的方法。在“bow”（Bag of Words - <code>CountVectorizer</code>）或“tf-idf”（TfidfVectorizer）之间进行选择。请注意，转换器的稀疏矩阵输出在内部转换为其完整阵列。这可能会导致大型文本嵌入的内存问题。</p>
</li>
<li><p><strong>ignore_features: list of string, default &#x3D; None</strong></p>
<p><code>ignore_features</code>可用于在模型训练期间忽略特征。它采用一个字符串列表，其中包含要忽略的列名。</p>
</li>
<li><p><strong>keep_features: list of str, default &#x3D; None</strong></p>
<p><code>keep_features</code>参数可以用于在预处理过程中始终保留特定的特征，即任何类型的特征选择都不会丢弃这些特征。它采用一个字符串列表，其中包含要保留的列名。</p>
</li>
</ul>
<p><strong>示例 - 分类特征(Categorical Features)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># load dataset</span><br><span class="line">from pycaret.datasets import get_data</span><br><span class="line">hepatitis = get_data(&#x27;hepatitis&#x27;)</span><br><span class="line"></span><br><span class="line"># init setup</span><br><span class="line">from pycaret.classification import *</span><br><span class="line">clf1 = setup(data = hepatitis, target = &#x27;Class&#x27;, categorical_features = [&#x27;AGE&#x27;])</span><br></pre></td></tr></table></figure>





<h3 id="2-3-数据准备-独热编码-One-Hot-Encoding"><a href="#2-3-数据准备-独热编码-One-Hot-Encoding" class="headerlink" title="2.3 数据准备 - 独热编码(One-Hot Encoding)"></a>2.3 数据准备 - 独热编码(One-Hot Encoding)</h3><p>数据集中的分类特征包含标签值（序数或标称值），而不是连续数。大多数机器学习算法不能直接处理分类特征，在训练模型之前必须将其转换为数值。最常见的分类编码类型是One-Hot编码（也称为伪编码），其中每个分类级别在包含二进制值（1或0）的数据集中成为一个单独的特征。</p>
<p>由于这是执行ML实验的必要步骤，PyCaret将使用一个独热编码(One-Hot Encoding)来转换数据集中的所有分类特征。这对于具有标称分类数据的特征是理想的，即数据无法排序。但在其他不同的场景中，必须使用其他编码方法。例如，当数据是有序的，即数据具有内在级别时，<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/preprocessing/data-preparation#ordinal-encoding">Ordinal Encoding</a>必须使用。One Hot Encoding适用于使用设置函数中的<code>categorical_features</code>推断为分类或强制为分类的所有特征。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>max_encoding_ohe: int, default &#x3D; 25</strong> </p>
<p>使用OneHotEncoding对唯一值或更少的列进行编码。如果更多，则使用<code>encoding method</code>(编码方法)估计器。请注意，只有两个类的列总是按顺序编码的。设置为0以下可始终使用OneHotEncoding。</p>
</li>
<li><p><strong>encoding_method: category-encoders estimator, default &#x3D; None</strong></p>
<p><code>category-encoders</code>(类别编码器)估计器，用于对具有超过<code>max_encoding_ohe</code>唯一值的分类列进行编码。如果无，则默认使用<code>category_encoders.leave_one_out.LeaveOneOutEncoder</code>。</p>
</li>
</ul>
<h3 id="2-4-数据准备-序数编码-Ordinal-Encoding"><a href="#2-4-数据准备-序数编码-Ordinal-Encoding" class="headerlink" title="2.4 数据准备 - 序数编码(Ordinal Encoding)"></a>2.4 数据准备 - 序数编码(Ordinal Encoding)</h3><p>当数据集中的分类特征包含具有内在自然顺序的变量，如<em>Low</em>、<em>Medium</em>和<em>High</em>时，这些变量的编码必须与标称变量不同（如男性或女性，没有内在顺序）。这可以使用<code>setup</code>函数中的<code>ordinal_features</code>参数来实现，该参数接受一个字典，字典中的功能名称和级别按从低到高的递增顺序排列。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>ordinal_features: dictionary, default &#x3D; None</strong></p>
<p>当数据包含有序特征时，必须使用<code>ordinal_features</code>对其进行不同的编码。如果数据有一个值为<code>low</code>、<code>medium</code>、<code>high</code>的分类变量，并且已知low&lt;medium&lt;high，则可以将其作为<code>ordinal_features=｛&#39;column_name&#39;：[‘low’、‘medium’、‘high’]｝</code>传递。列表序列必须按从低到高的递增顺序排列。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># load dataset</span><br><span class="line">from pycaret.datasets import get_data</span><br><span class="line">employee = get_data(&#x27;employee&#x27;)</span><br><span class="line"></span><br><span class="line"># init setup</span><br><span class="line">from pycaret.classification import *</span><br><span class="line">clf1 = setup(data = employee, target = &#x27;left&#x27;, ordinal_features = &#123;&#x27;salary&#x27; : [&#x27;low&#x27;, &#x27;medium&#x27;, &#x27;high&#x27;]&#125;)</span><br></pre></td></tr></table></figure>





<h3 id="2-5-数据准备-预测目标失衡-类内不平均-Target-Imbalance"><a href="#2-5-数据准备-预测目标失衡-类内不平均-Target-Imbalance" class="headerlink" title="2.5 数据准备 - 预测目标失衡&#x2F;类内不平均(Target Imbalance)"></a>2.5 数据准备 - 预测目标失衡&#x2F;类内不平均(Target Imbalance)</h3><p>当训练数据集的目标类分布不均衡时，可以使用设置中的<code>fix_imbalance</code>参数进行修复。当设置为<code>True</code>时，SMOTE（合成少数过采样技术）将用作重新采样的默认方法。可以使用设置中的<code>fix_imbalance_method</code>更改重新采样的方法。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>fix_imbalance: bool, default &#x3D; False</strong></p>
<p>当设置为<code>True</code>时，将使用<code>fix_imbalance_method</code>中定义的算法对训练数据集进行重新采样。当<code>None</code>时，默认情况下使用SMOTE。</p>
</li>
<li><p><strong>fix_imbalance_method: str or imblearn estimator, default &#x3D; ‘SMOTE’</strong></p>
<p>用于执行类平衡的估计器。从imbnear估计器的名称或其自定义实例中进行选择。当<code>fix_imbalance=False</code>时忽略。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">credit = get_data(<span class="string">&#x27;credit&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = credit, target = <span class="string">&#x27;default&#x27;</span>, fix_imbalance = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h3 id="2-6-数据准备-去除离群值-Remove-Outliers"><a href="#2-6-数据准备-去除离群值-Remove-Outliers" class="headerlink" title="2.6 数据准备 - 去除离群值(Remove Outliers)"></a>2.6 数据准备 - 去除离群值(Remove Outliers)</h3><p>PyCaret中的<code>remove_outliers</code>函数允许您在训练模型之前识别并删除数据集中的异常值。使用奇异值分解技术通过PCA线性降维来识别异常值。可以使用<a target="_blank" rel="noopener" href="https://www.pycaret.org/setup">setup</a>中的<code>remove_outliers</code>参数来实现。通过<code>outliers_threshold</code>参数控制异常值的比例。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>remove_outliers: bool, default &#x3D; False</strong></p>
<p>当设置为<code>True</code>时，将使用孤立森林(Isolation Forest)删除训练数据中的异常值。</p>
</li>
<li><p><strong>outliers_method: str, default &#x3D; ‘iforest’</strong></p>
<p>用于删除异常值的方法。<code>remove_outliers=False</code>时忽略。可能的值为：</p>
<ul>
<li><strong>‘iforest’:</strong> 使用sklearn的IsolationForest.</li>
<li><strong>‘ee’</strong>: 使用sklearn的EllipticEnvelope.</li>
<li><strong>‘lof’:</strong> 使用sklearn的LocalOutlierFactor.</li>
</ul>
</li>
<li><p><strong>outliers_threshold: float, default &#x3D; 0.05</strong></p>
<p>要从数据集中删除的异常值的百分比。在<code>remove_outliers=False</code>时忽略。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">insurance = get_data(<span class="string">&#x27;insurance&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.regression <span class="keyword">import</span> *</span><br><span class="line">reg1 = setup(data = insurance, target = <span class="string">&#x27;charges&#x27;</span>, remove_outliers = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>





<h3 id="2-7-数据规整与转换-规范化-归一化-Normalize"><a href="#2-7-数据规整与转换-规范化-归一化-Normalize" class="headerlink" title="2.7 数据规整与转换 - 规范化&#x2F;归一化(Normalize)"></a>2.7 数据规整与转换 - 规范化&#x2F;归一化(Normalize)</h3><p>规范化是一种经常作为机器学习数据准备的一部分应用的技术。规范化的目标是重新缩放数据集中数字列的值，而不会扭曲值范围的差异或丢失信息。有几种方法可用于规范化，默认情况下，PyCaret使用<code>zscore</code>。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>normalize: bool, default &#x3D; False</strong></p>
<p>当设置为<code>True</code>时，将使用<code>normalized_method</code>参数下定义的方法转换特征空间。</p>
</li>
<li><p><strong>normalize_method: string, default &#x3D; ‘zscore</strong>’</p>
<p>定义要使用的规范化方法。默认情况下，使用<code>zscore</code>。其可选项包括：</p>
<ul>
<li><strong><code>zscore</code></strong> 使用$z&#x3D;(x-u)&#x2F;s$对数据进行标准化。</li>
<li><strong><code>minmax</code></strong> 单独缩放和平移每个特征，使其处于0–1的范围内。</li>
<li><strong><code>maxabs</code></strong> 单独地缩放和平移每个特征，使得每个特征的最大绝对值将是1.0。它不会移动&#x2F;集中数据，因此不会破坏任何稀疏性。</li>
<li><strong><code>robust</code></strong> 根据四分位间距对每个特征进行缩放和平移。当数据集包含异常值时，鲁棒缩放器通常会给出更好的结果。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">pokemon = get_data(<span class="string">&#x27;pokemon&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = pokemon, target = <span class="string">&#x27;Legendary&#x27;</span>, normalize = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>







<h3 id="2-8-数据规整与转换-特征变换-Feature-Transform"><a href="#2-8-数据规整与转换-特征变换-Feature-Transform" class="headerlink" title="2.8 数据规整与转换 - 特征变换(Feature Transform)"></a>2.8 数据规整与转换 - 特征变换(Feature Transform)</h3><p>虽然<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/preprocessing/scale-and-transform#normalize">规范化</a>在新的限制范围内重新缩放数据以减少方差大小的影响，但特征变换是一种更激进的技术。变换改变分布的形状，使得变换后的数据可以由正态或近似正态分布表示。有两种方法可用于转换<code>yeo-johnson</code>和<code>quantile</code>。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>transformation: bool, default &#x3D; False</strong></p>
<p>当设置为True时，将应用强大的转换器以使数据更正态(normal )&#x2F;更高斯(Gaussian)。这对于建模与异方差或其他需要正态性的情况有关的问题很有用。通过最大似然估计稳定方差和最小化偏度的最优参数。</p>
</li>
<li><p><strong>transformation_method: string, default &#x3D; ‘yeo-johnson’</strong></p>
<p>定义转换的方法。默认情况下，转换方法设置为<code>yeo-johnson</code>。另一个可用的选项是分位数(<code>quantile</code>)转换。这两种转换都将特征集变换为遵循类高斯分布或正态分布。分位数变换器是非线性的，并且可能使以相同尺度测量的变量之间的线性相关性失真。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">pokemon = get_data(<span class="string">&#x27;pokemon&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = pokemon, target = <span class="string">&#x27;Legendary&#x27;</span>, transformation = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<p>![image-Feature Transform-after](images&#x2F;PyCaret&#x2F;image-Feature Transform-after.png)</p>
<p>![image-Feature Transform-effect](images&#x2F;PyCaret&#x2F;image-Feature Transform-effect.png)</p>
<h3 id="2-9-数据规整与转换-目标变换-Target-Transform"><a href="#2-9-数据规整与转换-目标变换-Target-Transform" class="headerlink" title="2.9 数据规整与转换 - 目标变换(Target Transform)"></a>2.9 数据规整与转换 - 目标变换(Target Transform)</h3><p>目标变换类似于特征变换，因为它将改变目标变量而不是特征的分布形状。此功能仅在<code>pycarte.regression</code>模块中可用。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>transform_target: bool, default &#x3D; False</strong></p>
<p>当设置为True时，将使用<code>transform_target_method</code>参数中定义的方法转换目标变量。目标变换与特征变换是分开应用的。</p>
</li>
<li><p><strong>transform_target_method: string, default &#x3D; ‘yeo-johnson’</strong></p>
<p>定义转换的方法。默认情况下，转换方法设置为<code>yeo-johnson</code>。转换的另一个可用选项是分位数。<code>transform_target=False</code>时忽略。</p>
</li>
</ul>
<p><strong>before</strong></p>
<p>![image-Target Transform-before](images&#x2F;PyCaret&#x2F;image-Target Transform-before.png)</p>
<p><strong>after</strong></p>
<p>![image-Target Transform-after](images&#x2F;PyCaret&#x2F;image-Target Transform-after.png)</p>
<h3 id="2-10-特征工程-多项式特征-Polynomial-Features"><a href="#2-10-特征工程-多项式特征-Polynomial-Features" class="headerlink" title="2.10 特征工程 - 多项式特征(Polynomial Features)"></a>2.10 特征工程 - 多项式特征(Polynomial Features)</h3><p>在机器学习实验中，常假设因变量和自变量之间的关系是线性的；然而，情况并非总是如此。有时，因变量和自变量之间的关系更为复杂。创建新的多项式特征有时可能有助于捕捉这种关系，否则可能会被忽视。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>polynomial_features: bool, default &#x3D; False</strong></p>
<p>当设置为True时，将基于数据集中数字特征中存在的所有多项式组合创建新特征，达到<code>polynomial_degree</code>参数中定义的程度。</p>
</li>
<li><p><strong>polynomial_degree: int, default &#x3D; 2</strong></p>
<p>多项式特征的次数。例如，如果输入样本是二维的，并且形式为[a，b]，则次数&#x3D;2的多项式特征为：[1，a，b，a^2，ab，b^2]。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">juice = get_data(<span class="string">&#x27;juice&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = juice, target = <span class="string">&#x27;Purchase&#x27;</span>, polynomial_features = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>![image-Polynomial Features-before](images&#x2F;PyCaret&#x2F;image-Polynomial Features-before.png)</p>
<p>![image-Polynomial Features-after](images&#x2F;PyCaret&#x2F;image-Polynomial Features-after.png)</p>
<h3 id="2-11-特征工程-分组特征-Group-Features"><a href="#2-11-特征工程-分组特征-Group-Features" class="headerlink" title="2.11 特征工程 - 分组特征(Group Features)"></a>2.11 特征工程 - 分组特征(Group Features)</h3><p>当数据集包含以某种方式相互关联的特征时，例如：以某些固定时间间隔记录的特征，则可以使用<code>group_features</code>参数从现有特征中创建一组此类特征的新统计特征，如均值、中值、方差和标准差。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>group_features: list or list of list, default &#x3D; None</strong></p>
<p>当数据集包含具有相关特征的特征时，group_features参数可用于统计特征提取。例如，如果数据集具有相互关联的数字特征（即“Col1”、“Col2”、“Col3”），则可以在<code>group_features</code>下传递包含列名的列表，以提取统计信息，如平均值、中值、模式和标准差。</p>
</li>
<li><p><strong>group_names: list, default &#x3D; None</strong></p>
<p>传递group_features时，组的名称可以作为包含字符串的列表传递到<code>group_names</code>参数中。group_names列表的长度必须等于<code>group_features</code>的长度。当长度不匹配或名称未传递时，将按顺序命名新特征，如group_1、group_2等。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">credit = get_data(<span class="string">&#x27;credit&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = credit, target = <span class="string">&#x27;default&#x27;</span>, group_features = [<span class="string">&#x27;BILL_AMT1&#x27;</span>, <span class="string">&#x27;BILL_AMT2&#x27;</span>, <span class="string">&#x27;BILL_AMT3&#x27;</span>, <span class="string">&#x27;BILL_AMT4&#x27;</span>, <span class="string">&#x27;BILL_AMT5&#x27;</span>, <span class="string">&#x27;BILL_AMT6&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>![image-Group Features-before](images&#x2F;PyCaret&#x2F;image-Group Features-before.png)</p>
<p>![image-Group Features-after](images&#x2F;PyCaret&#x2F;image-Group Features-after.png)</p>
<h3 id="2-12-特征工程-分仓数值特征-Bin-Numeric-Features"><a href="#2-12-特征工程-分仓数值特征-Bin-Numeric-Features" class="headerlink" title="2.12 特征工程 - 分仓数值特征(Bin Numeric Features)"></a>2.12 特征工程 - 分仓数值特征(Bin Numeric Features)</h3><p>特征分仓(Feature binning)是一种使用预定义数量，将连续变量分段转化为分类属性值的方法。当连续特征的唯一值过多或极值很少超出预期范围时，它是有效的。这样的极值影响训练的模型，从而影响模型的预测精度。在PyCaret中，可以使用<code>bin_numeric_features</code>参数将连续的数字特征分为区间。PyCaret使用“sturges”规则来确定分仓的数量，并使用K-Means聚类将连续的数值特征转换为分类特征。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>bin_numeric_features: list, default &#x3D; None</strong></p>
<p>当传递数字特征列表时，使用K-Means将其转换为分类特征，其中每个bin中的值具有1D K-Means聚类的相同最近中心。集群的数量是根据“sturges”方法确定的。它只对高斯数据是最优的，并且低估了大型非高斯数据集的bin数量。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">income = get_data(<span class="string">&#x27;income&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = income, target = <span class="string">&#x27;income &gt;50K&#x27;</span>, bin_numeric_features = [<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>![image-Bin Numeric Features-before](images&#x2F;PyCaret&#x2F;image-Bin Numeric Features-before.png)</p>
<p>![image-Bin Numeric Features-after](images&#x2F;PyCaret&#x2F;image-Bin Numeric Features-after.png)</p>
<h3 id="2-13-特征工程-组合稀有分类-Combine-Rare-Levels"><a href="#2-13-特征工程-组合稀有分类-Combine-Rare-Levels" class="headerlink" title="2.13 特征工程 - 组合稀有分类(Combine Rare Levels)"></a>2.13 特征工程 - 组合稀有分类(Combine Rare Levels)</h3><blockquote>
<p>将低频的分类值合并为一个分类属性</p>
</blockquote>
<p>有时，数据集可以具有一个分类特征（或多个分类特征），该分类特征具有非常高的级别数（即高基数特征-high cardinality features）。如果将这些特征编码为数值，则得到的矩阵是稀疏矩阵。这不仅由于特征数量和数据集大小的多重增加而使实验变得缓慢，而且还会在实验中引入噪声。稀疏矩阵可以通过组合具有高基数的特征中的稀有级别来避免。这可以在PyCaret中使用<code>rare_to_value</code>参数来实现。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>rare_to_value: float or None, default&#x3D;None</strong></p>
<p>类别列中出现的类别的最小分数。如果一个类别的频率低于<code>rare_to_value × len（X）</code>，则将其替换为rare_value中的字符串。使用此参数可以在对列进行编码之前对稀有类别进行分组。如果“无”，则忽略此步骤。																																															</p>
</li>
<li><p><strong>rare_value: str, default&#x3D;”rare”</strong></p>
<p>用于替换稀有类别的值。当<code>rare_to_value</code>为None时忽略。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">income = get_data(<span class="string">&#x27;income&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = income, target = <span class="string">&#x27;income &gt;50K&#x27;</span>, rare_to_value = <span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>

<p>![image-Combine Rare Levels-before](images&#x2F;PyCaret&#x2F;image-Combine Rare Levels-before.png)</p>
<p>![image-Combine Rare Levels-after](images&#x2F;PyCaret&#x2F;image-Combine Rare Levels-after.png)</p>
<p>![image-Combine Rare Levels-Effect](images&#x2F;PyCaret&#x2F;image-Combine Rare Levels-Effect.png)</p>
<h3 id="2-14-特征选择-Feature-Selection"><a href="#2-14-特征选择-Feature-Selection" class="headerlink" title="2.14 特征选择 - Feature Selection"></a>2.14 特征选择 - Feature Selection</h3><p>**特征重要性(Feature Importance)**是一个用于选择数据集中在预测目标变量方面贡献最大的特征的过程。使用选定的特征而不是所有特征可以降低过度拟合的风险，提高准确性，并减少训练时间。在PyCaret中，这可以使用<code>feature_selection</code>参数来实现。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>feature_selection: bool, default &#x3D; False</strong></p>
<p>当设置为True时，将基于由<code>feature_selection_estimator</code>确定的特征重要性分数来选择特征子集。</p>
</li>
<li><p><strong>feature_selection_method: str, default &#x3D; ‘classic’</strong></p>
<ul>
<li><strong>‘univariate’:</strong> 使用 sklearn’s SelectKBest.</li>
<li><strong>‘classic’:</strong> 使用 sklearn’s SelectFromModel.</li>
<li><strong>‘sequential’:</strong> 使用 sklearn’s SequentialFeatureSelector.</li>
</ul>
</li>
<li><p><strong>feature_selection_estimator: str or sklearn estimator, default &#x3D; ‘lightgbm’</strong></p>
<p>用于确定特征重要性的分类器。拟合后的估计器应具有<code>feature_importances_</code>或<code>coef_</code>属性。如果无，则使用LGB分类器(LGBClassifier)。当<code>feature_selection_method=univariate</code>时，将忽略此参数。</p>
</li>
<li><p><strong>n_features_to_select: int or float, default &#x3D; 0.2</strong></p>
<p>使用feature_selection可选择的最大功能数。如果＜1，则为起始特征的分数。请注意，此参数在计数时不考虑<code>ignore_features</code>或<code>keep_features</code>中的功能。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">diabetes = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.regression <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>, feature_selection = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>![image-Feature Selection-before](images&#x2F;PyCaret&#x2F;image-Feature Selection-before.png)</p>
<p>![image-Feature Selection-after](images&#x2F;PyCaret&#x2F;image-Feature Selection-after.png)</p>
<h3 id="2-15-特征选择-删除多重共线性特征-Remove-Multicollinearity"><a href="#2-15-特征选择-删除多重共线性特征-Remove-Multicollinearity" class="headerlink" title="2.15 特征选择 - 删除多重共线性特征(Remove Multicollinearity)"></a>2.15 特征选择 - 删除多重共线性特征(Remove Multicollinearity)</h3><p><strong>多重共线性-Multicollinearity</strong>（也称为共线<em>collinearity</em>）是一种数据集中的一个特征变量与另一特征变量高度线性相关的现象。多重共线性增加了系数的方差，从而使线性模型的系数不稳定且有噪声。处理多重共线的一种方法是放弃彼此高度相关的两个特征中的一个。可以在PyCaret中使用<code>remove_multicollinelity</code>参数来实现。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>remove_multicollinearity: bool, default &#x3D; False</strong></p>
<p>当设置为True时，高于定义阈值的互相关性特征将被删除。对于每个组，它将删除除与<code>y</code>具有最高相关性的特征之外的所有特征。</p>
</li>
<li><p><strong>multicollinearity_threshold: float, default &#x3D; 0.9</strong></p>
<p>确定相关特征的最小绝对Pearson相关性。默认值删除相等的列。当<code>remove_multicollinearity</code>不为True时忽略。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">concrete = get_data(<span class="string">&#x27;concrete&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.regression <span class="keyword">import</span> *</span><br><span class="line">reg1 = setup(data = concrete, target = <span class="string">&#x27;strength&#x27;</span>, remove_multicollinearity = <span class="literal">True</span>, multicollinearity_threshold = <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>

<p>![image-Remove Multicollinearity-before](images&#x2F;PyCaret&#x2F;image-Remove Multicollinearity-before.png)</p>
<p>![image-Remove Multicollinearity-after](images&#x2F;PyCaret&#x2F;image-Remove Multicollinearity-after.png)</p>
<h3 id="2-16-特征选择-主成分分析-Principal-Component-Analysis"><a href="#2-16-特征选择-主成分分析-Principal-Component-Analysis" class="headerlink" title="2.16 特征选择 - 主成分分析(Principal Component Analysis)"></a>2.16 特征选择 - 主成分分析(Principal Component Analysis)</h3><p>主成分分析（PCA）是一种在机器学习中用于降低数据维度的无监督技术。它通过识别一个子空间来压缩特征空间，该子空间捕获完整特征矩阵中的大部分信息。它将原始特征空间投影到较低维度。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>pca: bool, default &#x3D; False</strong></p>
<p>当设置为True时，将使用<code>pca_method</code>参数中定义的方法应用降维，将数据投影到较低维度的空间中。</p>
</li>
<li><p><strong>pca_method: string, default &#x3D; ‘linear’</strong></p>
<p>应用PCA的方法。可能的值为：</p>
<ul>
<li><strong>‘linear’:</strong> 使用 Singular Value Decomposition。</li>
<li><strong>‘kernel’:</strong> 使用 RBF kernel 进行降维。</li>
<li><strong>‘incremental’:</strong> 与 ‘linear’ 相似，但对大数据集更加有效率。</li>
</ul>
</li>
<li><p><strong>pca_components: int&#x2F;float, default &#x3D; 0.99</strong></p>
<p>要保留的组件数。如果 pca_components 是一个浮点值，则将其视为信息保留的目标百分比。当 pca_components 是一个整数时，它被视为要保留的特征数。pca_components 必须严格小于数据集中原始特征的数量。</p>
</li>
<li><p><strong>pca_components: int, float, str or None, default &#x3D; None</strong> </p>
<p>要保留的组件数。当<code>pca=False</code>时，将忽略此参数。</p>
<ul>
<li><strong>If None:</strong> 所有成分将会被保留。 </li>
<li><strong>If int:</strong> 组件的绝对值. </li>
<li><strong>If float:</strong> 需要解释的方差大于<code>n_components</code>指定的百分比。该值应介于0和1之间（仅适用于pca_thethod&#x3D;“线性”）。</li>
<li><strong>If ‘mle’:</strong> Minka’s MLE is used to guess the dimension (ony for pca_method&#x3D;’linear’).</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">income = get_data(<span class="string">&#x27;income&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = income, target = <span class="string">&#x27;income &gt;50K&#x27;</span>, pca = <span class="literal">True</span>, pca_components = <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>![image-Principal Component Analysis-before](images&#x2F;PyCaret&#x2F;image-Principal Component Analysis-before.png)</p>
<p>![image-Principal Component Analysis-after](images&#x2F;PyCaret&#x2F;image-Principal Component Analysis-after.png)</p>
<h3 id="2-17-特征选择-忽略低方差-Ignore-Low-Variance"><a href="#2-17-特征选择-忽略低方差-Ignore-Low-Variance" class="headerlink" title="2.17 特征选择 - 忽略低方差(Ignore Low Variance)"></a>2.17 特征选择 - 忽略低方差(Ignore Low Variance)</h3><p>有时，一个数据集可能具有多个级别的分类特征(categorical feature)，其中这些级别的分布是偏斜的，一个级别可能主导其他级别。这意味着由这种特征提供的信息没有太多变化。对于ML模型，这种特征可能不会添加很多信息，因此在建模时可以忽略。这可以在PyCaret中使用<code>low_variance_threshold</code>参数来实现。</p>
<p><strong>主要参数</strong></p>
<ul>
<li><p><strong>low_variance_threshold: float or None, default &#x3D; None</strong></p>
<p>删除训练集方差低于所提供阈值的特征。如果为0，则保留方差为非零的所有特征，即删除所有样本中具有相同值的特征。如果None，跳过此转换步骤。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">mice = get_data(<span class="string">&#x27;mice&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter dataset</span></span><br><span class="line">mice = mice[mice[<span class="string">&#x27;Genotype&#x27;</span>] == <span class="string">&#x27;Control&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = mice, target = <span class="string">&#x27;class&#x27;</span>, low_variance_threshold = <span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>

<p>![image-Ignore Low Variance-before](images&#x2F;PyCaret&#x2F;image-Ignore Low Variance-before.png)</p>
<p>![image-Ignore Low Variance-after](images&#x2F;PyCaret&#x2F;image-Ignore Low Variance-after.png)</p>
<h3 id="2-18-其他参数-实验日志-Experiment-Logging"><a href="#2-18-其他参数-实验日志-Experiment-Logging" class="headerlink" title="2.18 其他参数 - 实验日志(Experiment Logging)"></a>2.18 其他参数 - 实验日志(Experiment Logging)</h3><p>PyCaret可以自动记录整个实验，包括设置参数(setup parameters)、模型超参数(model hyperparameters)、性能指标(performance metrics)和管道工件(pipeline artifacts)。默认设置用<a target="_blank" rel="noopener" href="https://mlflow.org/">MLflow</a>作日志记录后端，<a target="_blank" rel="noopener" href="https://wandb.ai/">wandb</a>, <a target="_blank" rel="noopener" href="https://www.comet.com/site/">cometml</a>, <a target="_blank" rel="noopener" href="https://www.dagshub.com/">dagshub</a> 也可用于后端。可以启用设置中的参数来自动跟踪所有度量、超参数和模型工件。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>log_experiment: bool or str or BaseLogger or list of str or BaseLogger, default &#x3D; False</strong></p>
<p>与记录器相对应的 PyCaret <code>BaseLogger</code>或 str（<code>mlflow</code>、<code>wandb</code>、<code>comet_ml </code>或 <code>dagshub</code> 之一）的（列表），用于确定要使用哪些实验记录器。设置为True将仅使用MLFlow。</p>
</li>
<li><p><strong>experiment_name: str, default &#x3D; None</strong></p>
<p>日志记录实验的名称。当 <code>log_experiment=False</code> 时忽略。</p>
</li>
<li><p><strong>experiment_custom_tags: dict, default &#x3D; None</strong></p>
<p>标签名称的字典：字符串$\rightarrow$值：（字符串，但如果不是，将被字符串化）传递给mlflow.set_tags，为实验添加新的自定义标签。</p>
</li>
<li><p><strong>log_plots: bool or list, default &#x3D; False</strong></p>
<p>当设置为True时，某些绘图将自动记录在MLFlow服务器中。要更改要记录的打印类型，请传递包含打印IDs的列表。请参阅<code>plot_model</code>的文档。当<code>log_experiment=False</code>时忽略。</p>
</li>
<li><p><strong>log_profile: bool, default &#x3D; False</strong></p>
<p>当设置为True时，数据配置文件将作为html文件记录在MLflow服务器上。<br><code>log_experiment=False</code>时忽略</p>
</li>
<li><p><strong>log_data: bool, default &#x3D; False</strong></p>
<p>当设置为True时，训练和测试数据集将记录为CSV文件。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">data = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data, target = <span class="string">&#x27;Class variable&#x27;</span>, log_experiment = <span class="literal">True</span>, experiment_name = <span class="string">&#x27;diabetes1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># model training</span></span><br><span class="line">best_model = compare_models() </span><br></pre></td></tr></table></figure>

<p>若要初始化MLflow服务器，必须在笔记本中或命令行中运行以下命令。服务器初始化后，您可以在上跟踪您的实验<a target="_blank" rel="noopener" href="https://localhost:5000/">https://localhost:5000</a>.</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># init server</span><br><span class="line">!mlflow ui</span><br></pre></td></tr></table></figure>

<p>![image-Experiment Logging-MLflow](images&#x2F;PyCaret&#x2F;image-Experiment Logging-MLflow.png)</p>
<p><strong>配置MLflow跟踪服务器</strong></p>
<p>当没有配置后端时，数据本地存储在提供的文件中（如果为空，则为.&#x2F;mlrun）。要配置后端，请在执行设置函数之前使用mlflow.set_tracking_uri。</p>
<ul>
<li><p>一个空字符串或本地文件路径，前缀为file:&#x2F;。数据本地存储在提供的文件中（如果为空，则为.&#x2F;mlrun）。</p>
</li>
<li><p>像这样的HTTP URI <a target="_blank" rel="noopener" href="https://my-tracking-server:5000/">https://my-tracking-server:5000</a>.</p>
</li>
<li><p>Databricks工作区，以字符串“databricks”提供，或者，若要使用Databricks CLI 配置文件，则以“databricks:&#x2F;&#x2F;&lt;profileName&gt;”提供。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set tracking uri </span></span><br><span class="line"><span class="keyword">import</span> mlflow </span><br><span class="line">mlflow.set_tracking_uri(<span class="string">&#x27;file:/c:/users/mlflow-server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">data = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data, target = <span class="string">&#x27;Class variable&#x27;</span>, log_experiment = <span class="literal">True</span>, experiment_name = <span class="string">&#x27;diabetes1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>PyCaret on Databricks</strong></p>
<p>在Databricks上使用PyCaret时，设置中的<code>experiment_name</code>参数必须包括到存储的完整路径。请参阅以下使用Databricks时如何记录实验的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">data = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data, target = <span class="string">&#x27;Class variable&#x27;</span>, log_experiment = <span class="literal">True</span>, experiment_name = <span class="string">&#x27;/Users/username@domain.com/experiment-name-here&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-19-其他参数-模型选择-Model-Selection"><a href="#2-19-其他参数-模型选择-Model-Selection" class="headerlink" title="2.19 其他参数 - 模型选择(Model Selection)"></a>2.19 其他参数 - 模型选择(Model Selection)</h3><p>setup中的以下参数，可用于模型选择的过程。这些与数据预处理无关，但可能会影响模型选择过程。</p>
<p><strong>相关参数</strong></p>
<ul>
<li><p><strong>train_size: float, default &#x3D; 0.7</strong></p>
<p>用于训练和验证的数据集的比例。</p>
</li>
<li><p><strong>test_data: dataframe-like or None, default &#x3D; None</strong></p>
<p>如果不是<code>None</code>，则将<code>test_data</code>用作保留集(hold-out set)，并忽略train_size参数。data和test_data中的列必须完全匹配。</p>
<blockquote>
<p>test_data的添加会大幅度影响模型选择过程中的精度。</p>
<p>基于目前已有的实验的猜测：</p>
<ul>
<li>现象1：设定test_data之后的性能指标明显变低，但是和最终预测的结果吻合的比较好。</li>
<li>现象2：test_data在这里由称为保留集，如果只是针对test_data来训练，不应该进行交叉验证。</li>
<li>猜测：经过查询，保留集这个概念应该和交叉验证有很大的关系，因为每次交叉验证都会取一部分数据作为验证集。所以可能需要在训练过程中禁用交叉验证。</li>
</ul>
</blockquote>
</li>
<li><p><strong>data_split_shuffle: bool, default &#x3D; True</strong></p>
<p>设置为<code>False</code>时，可防止在<code>train_test_split</code>过程中打乱行。</p>
</li>
<li><p><strong>data_split_stratify: bool or list, default &#x3D; True</strong></p>
<p>控制<code>train_test_split</code>过程中的分层。当设置为<code>True</code>时，它将按目标列进行分层。若要对任何其他列进行分层，请传递列名列表。当<code>data_split_shuffle</code>为<code>False</code>时忽略。</p>
</li>
<li><p><strong>fold_strategy: str or scikit-learn CV generator object, default &#x3D; ‘stratifiedkfold’</strong></p>
</li>
<li><p><strong>fold:</strong> int, default &#x3D; 10</p>
</li>
<li><p><strong>fold_shuffle:</strong> bool, default &#x3D; False</p>
</li>
<li><p><strong>fold_groups:</strong> str or array-like, with shape (n_samples,), default &#x3D; None</p>
</li>
</ul>
<h3 id="2-20-其他参数"><a href="#2-20-其他参数" class="headerlink" title="2.20 其他参数"></a>2.20 其他参数</h3><p>设置中的以下参数可用于控制其他实验设置，例如使用GPU进行训练或设置实验的详细程度。它们不会以任何方式影响数据。</p>
<p><strong>具体参数：</strong></p>
<ul>
<li><p><strong>n_jobs: int, default &#x3D; -1</strong></p>
<p>并行运行的作业数（对于支持并行处理的函数）-1表示使用所有处理器。要在单处理器上运行所有功能，请设置n_jobs&#x3D;无</p>
</li>
<li><p><strong>use_gpu: bool or str, default &#x3D; False</strong></p>
<p>当设置为<code>True</code>时，支持GPU的算法将使用GPU进行训练，如果不可用，则使用CPU。当设置为<code>force</code>时，它将仅使用启用GPU的算法，并在不可用时引发异常。当为<code>False</code>时，所有算法都只使用CPU进行训练。目前启用GPU的算法如下：</p>
<ul>
<li>Extreme Gradient Boosting, requires no further installation</li>
<li>CatBoost Classifier, requires no further installation (GPU training is only enabled when data &gt; 50,000 rows)</li>
<li>Light Gradient Boosting Machine, requires GPU installation <a target="_blank" rel="noopener" href="https://lightgbm.readthedocs.io/en/latest/GPU-Tutorial.html">Tutorial</a> </li>
<li>Logistic Regression, Ridge Classifier, Random Forest, K Neighbors Classifier, Support Vector Machine, requires cuML &gt;&#x3D; 0.15 <a target="_blank" rel="noopener" href="https://github.com/rapidsai/cuml">cuML</a></li>
</ul>
</li>
<li><p><strong>session_id: int, default &#x3D; None</strong></p>
<p>控制实验的随机性。它相当于scikit learn中的<code>random_state</code>。当<code>None</code>时，将生成一个伪随机数。这可以保证后续整个实验的再现性。</p>
</li>
<li><p><strong>verbose: bool, default &#x3D; True</strong></p>
<p>设置为<code>False</code>时，不打印信息网格。</p>
</li>
<li><p><strong>profile: bool, default &#x3D; False</strong></p>
<p>当设置为<code>True</code>时，将显示交互式EDA报告。</p>
</li>
<li><p><strong>profile_kwargs: dict, default &#x3D; {} (empty dict)</strong></p>
<p>传递给用于创建EDA报告的<code>ProfileReport</code>方法的参数字典。如果<code>profile</code>为<code>False</code>，则忽略。</p>
</li>
<li><p><strong>custom_pipeline: list of (str, transformer), dict or Pipeline, default &#x3D; None</strong></p>
<p>额外的自定义转换器。如果通过，则在所有内置转换器之后，它们最后应用于管道。</p>
</li>
<li><p><strong>custom_pipeline_position: int, default &#x3D; -1</strong> </p>
<p>自定义管道在整个预处理管道中的位置。默认值最后添加自定义管道。</p>
</li>
<li><p><strong>preprocess: bool, default &#x3D; True</strong></p>
<p>设置为<code>False</code>时，除了在<code>custom_pipeline</code>参数中传递的<code>train_test_split</code>和自定义转换外，不应用其他任何转换。当预处理设置为<code>False</code>时，数据必须先准备好再进行建模（没有缺失值、没有日期、分类数据编码）。</p>
</li>
<li><p><strong>system_log: bool or str or logging.Logger, default &#x3D; True</strong></p>
<p>是否保存系统日志文件（作为logs.log）。如果输入的是字符串，将其用作日志文件的路径。如果输入已经是记录器对象，会使用该对象。</p>
</li>
<li><p><strong>memory: str, bool or Memory, default&#x3D;True</strong></p>
<p>用于缓存管道的已配置好的转换器。</p>
<ul>
<li>If False：则不执行缓存。</li>
<li>If True：则使用默认的临时目录。</li>
<li>If str：缓存目录的路径。</li>
</ul>
</li>
</ul>
<h2 id="3-Train-比较模型-compare-models"><a href="#3-Train-比较模型-compare-models" class="headerlink" title="3. Train-比较模型-compare_models"></a>3. Train-比较模型-<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/train#compare_models">compare_models</a></h2><p><img src="/images/PyCaret/PyCaret-workflow-3.jpg" alt="PyCaret-workflow-3"></p>
<p>在PyCaret的 <code>setup()</code>完成后，建议将所有模型进行比较以评估性能(除非你确切知道需要什么类型的模型，通常情况下并非如此)，该函数使用交叉验证来训练和评估模型库中所有可用估计器的性能。该函数的输出是一个具有平均交叉验证分数的评分网格。</p>
<blockquote>
<p>可以使用<code>get_Metrics</code>函数访问CV期间评估的度量。</p>
<p>也可以使用<code>add_metric</code>和<code>remove_metric</code>函数添加或删除自定义度量。</p>
</blockquote>
<p>对于回归预测的任务，输出将打印一个分数网格，该网格显示模型、平均绝对误差（MAE）、均方误差（MSE）、确定系数（R^2^）、均方根误差（RMSE）、平均绝对百分比误差（MAPE）以及训练时间（TT）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best_model = compare_models()</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-compare_models-1.png" alt="compare_models-1"></p>
<p><code>compare_models()</code>函数的作用是：一次比较多个模型。这是使用PyCaret的最大优点之一。在一行中，你可以看到许多模型之间的预测精度比较表。两个简单的单词(甚至不是一行代码)已经使用N倍交叉验证训练和评估了超过15个模型。</p>
<h3 id="3-1-N-Fold-交叉验证"><a href="#3-1-N-Fold-交叉验证" class="headerlink" title="3.1 N-Fold 交叉验证"></a>3.1 N-Fold 交叉验证</h3><blockquote>
<p>&#x3D;&#x3D;todo&#x3D;&#x3D; - 可以重写或细化这里</p>
<p>相关参考：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/471342052">https://zhuanlan.zhihu.com/p/471342052</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/bd/art/130875911?source_id=1001">https://www.zhihu.com/tardis/bd/art/130875911?source_id=1001</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/encoding_utf_8/article/details/103225187">https://blog.csdn.net/encoding_utf_8/article/details/103225187</a></p>
</blockquote>
<p>为更好的理解PyCaret是如何对模型进行比较，有必要对N-fold交叉验证的概念进行理解。</p>
<p>计算有多少数据应该划分到测试集中是一个微妙的问题。如果训练集太小，算法可能没有足够的数据来有效地学习。另一方面，如果测试集太小，准确度、精确度、召回率和F1分数可能会有很大的变化。</p>
<p>你可能很幸运，也可能很不幸！一般来说，将70%的数据放在训练集中，30%的数据放在测试集中是一个很好的起点。有时数据集太小了，70&#x2F;30也会产生很大的差异。</p>
<p>一种解决方法是执行N折交叉验证。这里的中心思想是，将整个过程进行N次，然后平均精度。例如，在10折交叉验证中，将测试集的前10%的数据，并计算准确度、精确度、召回率和F1分数。然后，将使交叉验证建立第二个10%的数据，再次计算这些统计数据。最终，这个过程就进行10次，每次测试集都会有不同的数据，随后平均所有的准确度作为参考标准。</p>
<blockquote>
<p>图注：验证集(这里是黄色)被认为是案例中的测试集</p>
</blockquote>
<img src="images/PyCaret/image-compare_models-Kfold.png" alt="compare_models-Kfold" style="zoom: 67%;" />

<blockquote>
<p>在K-最近邻算法中，当增加或减少K时，精确度会变化（未知）。一旦对模型的性能感到满意，就应该输入验证集以得到最终的模型(此时的模型相当于使用的训练集和验证集所有的数据，泛化性将只能使用测试集进行测试)。</p>
<p>整体上，交叉验证的工作原理与验证集&#x2F;测试集体系非常相似，只是在构建或优化模型时有所区别。统一的是，通过找到一种精度指标，更好地了解算法在现实世界中的性能。 </p>
</blockquote>
<h3 id="3-2-改变排序标准-Change-the-sort-order"><a href="#3-2-改变排序标准-Change-the-sort-order" class="headerlink" title="3.2 改变排序标准 - Change the sort order"></a>3.2 改变排序标准 - Change the sort order</h3><p>打印的表格可以突出显示了最高性能指标，仅供比较之用。默认表使用“R^2^”(从最高到最低)排序，也可以通过传递参数来更改。如<code>compare_models(sort = &#39;TT&#39;)</code>将根据TT对模型进行排序，效果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best_model = compare_models(sort = <span class="string">&#x27;TT&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>![Change the sort order](images&#x2F;PyCaret&#x2F;image-compare_models-Change the sort order.png)</p>
<h3 id="3-3-仅比较部分模型-Compare-only-a-few-models-include-exclude"><a href="#3-3-仅比较部分模型-Compare-only-a-few-models-include-exclude" class="headerlink" title="3.3 仅比较部分模型 - Compare only a few models(include&#x2F;exclude)"></a>3.3 仅比较部分模型 - Compare only a few models(include&#x2F;exclude)</h3><p>使用<code>include</code>参数，可以仅比较您选择的几个模型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best_model = compare_models(include = [<span class="string">&#x27;lr&#x27;</span>, <span class="string">&#x27;dt&#x27;</span>, <span class="string">&#x27;lightgbm&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>或者使用<code>exclude</code>参数，将比较除exclude参数中传递的模型之外的所有模型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best_model = compare_models(exclude = [<span class="string">&#x27;lr&#x27;</span>, <span class="string">&#x27;dt&#x27;</span>, <span class="string">&#x27;lightgbm&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h3 id="3-4-返回多个模型结果-Return-more-than-one-model-n-select"><a href="#3-4-返回多个模型结果-Return-more-than-one-model-n-select" class="headerlink" title="3.4 返回多个模型结果 - Return more than one model(n_select)"></a>3.4 返回多个模型结果 - Return more than one model(n_select)</h3><p>默认情况下，<code>compare_models()</code>只返回性能最高的模型，但如果您愿意，您可以获得前N个模型的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_best_model = compare_models(n_select = <span class="number">3</span>)</span><br><span class="line">top1_model, top2_model, top3_model = compare_models(n_select = <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-5-设定预算时间-Set-the-budget-time-budget-time"><a href="#3-5-设定预算时间-Set-the-budget-time-budget-time" class="headerlink" title="3.5 设定预算时间 - Set the budget time(budget_time )"></a>3.5 设定预算时间 - Set the budget time(budget_time )</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best = compare_models(budget_time = <span class="number">0.5</span>)  <span class="comment"># 超过0.5s的模型不再参与模型比较</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-设置概率阈值-Set-the-probability-threshold"><a href="#3-6-设置概率阈值-Set-the-probability-threshold" class="headerlink" title="3.6 设置概率阈值 - Set the probability threshold"></a>3.6 设置概率阈值 - Set the probability threshold</h3><p>执行&#x3D;&#x3D;二进制分类&#x3D;&#x3D;时，可以更改硬标签的概率阈值或截止值。默认情况下，所有分类器都使用0.5作为默认阈值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best = compare_models(probability_threshold = <span class="number">0.25</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，这个参数主用于<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/modules">分类任务</a>中。</p>
<p>除了AUC之外的所有指标现在都不同了。AUC不会改变，因为它不取决于硬标签，其他一切都取决于现在使用probability_threshold&#x3D;0.25获得的硬标签。</p>
</blockquote>
<h3 id="3-7-禁用交叉验证-Disable-cross-validation"><a href="#3-7-禁用交叉验证-Disable-cross-validation" class="headerlink" title="3.7 禁用交叉验证 - Disable cross-validation"></a>3.7 禁用交叉验证 - Disable cross-validation</h3><p>如果你不想使用交叉验证来评估模型，而只是训练它们并查看测试&#x2F;保持集上的指标，你可以将<code>cross_validation=False</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best = compare_models(cross_validation=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>仅在<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/modules">分类</a>和<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/modules">回归</a>任务中有效。</p>
</blockquote>
<h3 id="3-8-查看模型参数-Model-parameter"><a href="#3-8-查看模型参数-Model-parameter" class="headerlink" title="3.8 查看模型参数 - Model parameter"></a>3.8 查看模型参数 - Model parameter</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(best_model)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-compare_models-show_model_para.png" alt="image-20230703204801697"></p>
<h3 id="3-9-集群上的分布式训练-Distributed-training-on-a-cluster"><a href="#3-9-集群上的分布式训练-Distributed-training-on-a-cluster" class="headerlink" title="3.9 集群上的分布式训练 - Distributed training on a cluster"></a>3.9 集群上的分布式训练 - Distributed training on a cluster</h3><p>要在大型数据集上进行扩展，可以使用名为parallel的参数在分布式模式下的集群上运行<code>compare_models</code>函数。它利用<a target="_blank" rel="noopener" href="https://github.com/fugue-project/fugue/">Fugue</a>抽象层在Spark或Dask集群上运行<code>compare_models</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">diabetes = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>, n_jobs = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create pyspark session</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line">spark = SparkSession.builder.getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="comment"># import parallel back-end</span></span><br><span class="line"><span class="keyword">from</span> pycaret.parallel <span class="keyword">import</span> FugueBackend</span><br><span class="line"></span><br><span class="line"><span class="comment"># compare models</span></span><br><span class="line">best = compare_models(parallel = FugueBackend(spark))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，为了使用本地Spark进行测试，我们需要在设置中设置n_jobs&#x3D;1，因为有些模型已经尝试使用所有可用的内核，而并行运行这些模型可能会导致资源争用导致的死锁。</p>
</blockquote>
<p>对于Dask，我们可以在FugueBackend中指定“Dask”，它将提取可用的Dask客户端。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">diabetes = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>, n_jobs = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># import parallel back-end</span></span><br><span class="line"><span class="keyword">from</span> pycaret.parallel <span class="keyword">import</span> FugueBackend</span><br><span class="line"></span><br><span class="line"><span class="comment"># compare models</span></span><br><span class="line">best = compare_models(parallel = FugueBackend(<span class="string">&quot;dask&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>有关分布式执行的完整示例和其他功能，请查看<a target="_blank" rel="noopener" href="https://github.com/pycaret/pycaret/blob/master/examples/PyCaret%202%20Fugue%20Integration.ipynb">这个示例</a>。此示例还显示了如何实时获取排行榜。在分布式设置中，这涉及到设置RPCClient，但Fugue简化了这一点。</p>
<h2 id="4-Train-创建模型-create-model"><a href="#4-Train-创建模型-create-model" class="headerlink" title="4. Train-创建模型-create_model"></a>4. Train-创建模型-<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/train#create_model">create_model</a></h2><p><img src="/images/PyCaret/PyCaret-workflow-4.jpg" alt="workflow-4"></p>
<p><code>create_model()</code>是PyCaret中最细粒度的函数，通常是PyCaret大多数功能的基础。正如它的名字所示，该函数使用交叉验证来训练和评估给定估计器的性能。此函数的输出是一个按倍数显示CV分数的评分网格。可以使用<code>get_Metrics</code>函数访问CV期间评估的度量。可以使用<code>add_metric</code>和<code>remove_metric</code>函数添加或删除自定义度量。所有可用的模型都可以使用模型功能访问。</p>
<p>对于回归预测任务，输出将打印一个计分表，按 Fold 显示MAE、MSE、RMSE、R2、RMSLE、MAPE。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rf=create_model(<span class="string">&#x27;rf&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-create_model-1.png" alt="image-20230706114155919"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rf=create_model(<span class="string">&#x27;rf&#x27;</span>,return_train_score=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-create_model-2.png" alt="image-20230709220925757"></p>
<p>当设置<code>return_train_score=True</code>时，交叉验证的结果将包括在训练集上计算得到的性能指标。这意味着除了在验证集上评估模型性能之外，还会提供模型在每个交叉验证折叠中在训练集上的性能指标。</p>
<p>当设置<code>return_train_score=False</code>时，默认行为是只返回在验证集上计算得到的性能指标，不包括训练集上的性能指标。</p>
<p>所有模型的平均分数与<code>compare_models()</code>上打印的分数匹配。这是因为<code>compare_models()</code>分数网格中打印的指标是所有折的平均分数。</p>
<p>还可以在每个模型的每个<code>print()</code>中看到用于构建它们的超参数。这是非常重要的，因为它是改进它们的基础。在下面的例子中，你可以看到Random Forest Regressor的参数。</p>
<p><img src="/images/PyCaret/image-create_model-show_model_para.png" alt="image-20230706114558448"></p>
<h3 id="4-1-查看可用的模型-Model-library"><a href="#4-1-查看可用的模型-Model-library" class="headerlink" title="4.1 查看可用的模型 - Model library"></a>4.1 查看可用的模型 - Model library</h3><p>对于预测回归任务，PyCaret模型库中有26个回归器可用。要查看所有分类器的列表，可查看文档或使用<code>models()</code>函数进行查看。</p>
<p><img src="/images/PyCaret/image-compare_models-show_model.png" alt="image-compare_models-show_model"></p>
<h3 id="4-2-改变模型训练参数"><a href="#4-2-改变模型训练参数" class="headerlink" title="4.2 改变模型训练参数"></a>4.2 改变模型训练参数</h3><p><strong>更改交叉验证(fold)参数 - Changing the fold param</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr = create_model(<span class="string">&#x27;lr&#x27;</span>, fold = <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p><strong>改变模型中的自定义参数 - Models with custom param</strong>  </p>
<p>如果你更改模型中的超参数设置，可以使用下面的方式。以决策树为例，改变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># train decision tree</span><br><span class="line">dt = create_model(&#x27;dt&#x27;, max_depth = 5)</span><br></pre></td></tr></table></figure>

<p>![image-Train-model with custom param](images&#x2F;PyCaret&#x2F;image-Train-model with custom param.png)</p>
<h3 id="4-3-访问评分网络-Access-the-scoring-grid"><a href="#4-3-访问评分网络-Access-the-scoring-grid" class="headerlink" title="4.3 访问评分网络 - Access the scoring grid"></a>4.3 访问评分网络 - Access the scoring grid</h3><p>您在<code>create_model</code>之后看到的性能指标&#x2F;评分网格仅显示，不会返回。因此，如果您想以<code>pandas.DataFrame</code>的形式访问该网格。可以在<code>create_model</code>之后立刻使用<code>pull</code>命令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># train decision tree</span></span><br><span class="line">dt = create_model(<span class="string">&#x27;dt&#x27;</span>, max_depth = <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># access the scoring grid</span></span><br><span class="line">dt_results = pull()</span><br><span class="line"><span class="built_in">print</span>(dt_results)</span><br></pre></td></tr></table></figure>

<p>![image-Train-access the scoring grid](images&#x2F;PyCaret&#x2F;image-Train-access the scoring grid.png)</p>
<h3 id="4-4-禁用交叉验证-Disable-cross-validation"><a href="#4-4-禁用交叉验证-Disable-cross-validation" class="headerlink" title="4.4 禁用交叉验证 - Disable cross-validation"></a>4.4 禁用交叉验证 - Disable cross-validation</h3><p>如果你不想使用交叉验证来评估模型，而只是训练它们并查看测试&#x2F;保持集上的指标，你可以将<code>cross_validation</code>设置为False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr = create_model(<span class="string">&#x27;lr&#x27;</span>, cross_validation = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>![image-train-disable cross_validation](images&#x2F;PyCaret&#x2F;image-train-disable cross_validation.png)</p>
<p>这些是测试&#x2F;保持集上的指标。这就是为什么在原始输出中只看到一行，而不是12行。禁用交叉验证时，模型只在整个训练数据集上训练一次，并使用测试&#x2F;保持集进行评分。</p>
<blockquote>
<p>注意：此功能仅在“分类”和“回归”模块中可用。</p>
</blockquote>
<h3 id="4-5-返回训练得分-Return-train-score"><a href="#4-5-返回训练得分-Return-train-score" class="headerlink" title="4.5 返回训练得分 - Return train score"></a>4.5 返回训练得分 - Return train score</h3><p>默认的评分网格按倍数显示验证集的性能指标。如果您还想按倍数查看训练集上的性能指标，以检查拟合过度&#x2F;拟合不足，可以使用<code>return_train_score</code>参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr = create_model(<span class="string">&#x27;lr&#x27;</span>, return_train_score = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>![image_train_Return train score](images&#x2F;PyCaret&#x2F;image_train_Return train score.png)</p>
<h3 id="4-6-设置概率阈值-Set-the-probability-threshold"><a href="#4-6-设置概率阈值-Set-the-probability-threshold" class="headerlink" title="4.6 设置概率阈值 - Set the probability threshold"></a>4.6 设置概率阈值 - Set the probability threshold</h3><p>执行二进制分类时，可以更改硬标签的概率阈值或截止值。默认情况下，所有分类器都使用0.5作为默认阈值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr = create_model(<span class="string">&#x27;lr&#x27;</span>, probability_threshold = <span class="number">0.25</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-7-循环训练模型-Train-models-in-a-loop"><a href="#4-7-循环训练模型-Train-models-in-a-loop" class="headerlink" title="4.7 循环训练模型 - Train models in a loop"></a>4.7 循环训练模型 - Train models in a loop</h3><p>您可以在循环中使用<code>create_model</code>函数来训练多个模型，甚至是具有不同配置的同一模型，并比较它们的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># train models in a loop</span></span><br><span class="line">lgbs  = [create_model(<span class="string">&#x27;lightgbm&#x27;</span>, learning_rate = i) <span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">0.1</span>,<span class="number">1</span>,<span class="number">0.1</span>)]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，此时返回的是模型的列表</p>
</blockquote>
<p>![image_Train_Train models in a loop](images&#x2F;PyCaret&#x2F;image_Train_Train models in a loop.png)</p>
<p>如果你想和大多数情况下一样跟踪指标，可以这样做。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># load dataset </span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data </span><br><span class="line">diabetes = get_data(<span class="string">&#x27;diabetes&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> * </span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># start a loop</span></span><br><span class="line">models = []</span><br><span class="line">results = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">0.1</span>,<span class="number">1</span>,<span class="number">0.1</span>):</span><br><span class="line">    model = create_model(<span class="string">&#x27;lightgbm&#x27;</span>, learning_rate = i)</span><br><span class="line">    model_results = pull().loc[[<span class="string">&#x27;Mean&#x27;</span>]]</span><br><span class="line">    models.append(model)</span><br><span class="line">    results.append(model_results)</span><br><span class="line">    </span><br><span class="line">results = pd.concat(results, axis=<span class="number">0</span>)</span><br><span class="line">results.index = np.arange(<span class="number">0.1</span>,<span class="number">1</span>,<span class="number">0.1</span>)</span><br><span class="line">results.plot()</span><br></pre></td></tr></table></figure>

<p>![image_Train_Output from results.plot()](images&#x2F;PyCaret&#x2F;image_Train_Output from results.plot().png)</p>
<h3 id="4-8-训练自定义模型-Train-custom-models"><a href="#4-8-训练自定义模型-Train-custom-models" class="headerlink" title="4.8 训练自定义模型 - Train custom models"></a>4.8 训练自定义模型 - Train custom models</h3><p>您可以使用自己的自定义模型进行训练，也可以使用不属于pycaret的其他库中的模型。只要他们的API与<code>sklearn</code>保持一致，它就会轻而易举地工作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install gplearn library</span></span><br><span class="line"><span class="comment"># pip install gplearn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># load dataset </span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data </span><br><span class="line">diabetes = get_data(<span class="string">&#x27;diabetes&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> * </span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># import custom model</span></span><br><span class="line"><span class="keyword">from</span> gplearn.genetic <span class="keyword">import</span> SymbolicClassifier</span><br><span class="line">sc = SymbolicClassifier()</span><br><span class="line"></span><br><span class="line"><span class="comment"># train custom model</span></span><br><span class="line">sc_trained = create_model(sc)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(sc_trained)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; gplearn.genetic.SymbolicClassifier</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sc_trained)</span><br></pre></td></tr></table></figure>

<p>![image_Train_Train custom models](images&#x2F;PyCaret&#x2F;image_Train_Train custom models.png)</p>
<h3 id="4-9-编写自己的模型-Write-your-own-models"><a href="#4-9-编写自己的模型-Write-your-own-models" class="headerlink" title="4.9 编写自己的模型 - Write your own models"></a>4.9 编写自己的模型 - Write your own models</h3><p>您也可以使用<code>fit</code>和<code>predict</code>函数编写自己的类。PyCaret将与之兼容。下面是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset </span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data </span><br><span class="line">insurance= get_data(<span class="string">&#x27;insurance&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.regression <span class="keyword">import</span> * </span><br><span class="line">reg1 = setup(data = insurance, target = <span class="string">&#x27;charges&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create custom estimator</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyOwnModel</span>(<span class="title class_ inherited__">BaseEstimator</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.mean = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X, y</span>):</span><br><span class="line">        self.mean = y.mean()</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">return</span> np.array(X.shape[<span class="number">0</span>]*[self.mean])</span><br><span class="line">        </span><br><span class="line"><span class="comment"># create an instance</span></span><br><span class="line">my_own_model = MyOwnModel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># train model</span></span><br><span class="line">my_model_trained = create_model(my_own_model)</span><br></pre></td></tr></table></figure>

<p>![image_Train_Write your own models](images&#x2F;PyCaret&#x2F;image_Train_Write your own models.png)</p>
<h2 id="5-Optimize-调整模型-tune-model"><a href="#5-Optimize-调整模型-tune-model" class="headerlink" title="5. Optimize-调整模型-tune_model"></a>5. Optimize-调整模型-<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/optimize#tune_model">tune_model</a></h2><p><img src="/images/PyCaret/PyCaret-workflow-5.jpg" alt="PyCaret-workflow-"></p>
<p>在使用<code>create_model()</code>函数创建模型时，使用的是默认的超参数。使用<code>tune_model()</code>函数可以自动对超参数进行调整。该函数将在预定义搜索空间中的使用随机网格搜索自动调整模型的超参数，即超参数调优。</p>
<p>要自定义搜索网格，可以在tune_model函数中传递<code>custom_grid</code>参数。</p>
<h3 id="5-1-使用方式及精度提升"><a href="#5-1-使用方式及精度提升" class="headerlink" title="5.1 使用方式及精度提升"></a>5.1 使用方式及精度提升</h3><p><strong>首先是原始模型精度</strong></p>
<p><img src="/images/PyCaret/image-tune_model-1.png" alt="tune_model-1"></p>
<p><strong>随后使用<code>tune_model()</code>调整模型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tuned_knn=tune_model(knn)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-tune_model-2.png" alt="image-tune_model-2"></p>
<p>&#x3D;&#x3D;可以看出R2从0.34提高到了0.38&#x3D;&#x3D;</p>
<p><img src="/images/PyCaret/image-tune_model-3.png" alt="image-20230706155220504"></p>
<p>&#x3D;&#x3D;打印出来的模型参数也有变化&#x3D;&#x3D;</p>
<blockquote>
<p>注意：并不是所有模型使用tune_model后都会提高。（这里只是knn提高了，像rf&#x2F;et&#x2F;xgboost这些试了后并没有提高）</p>
</blockquote>
<h3 id="5-2-增加迭代-Increasing-the-iteration"><a href="#5-2-增加迭代-Increasing-the-iteration" class="headerlink" title="5.2 增加迭代 - Increasing the iteration"></a>5.2 增加迭代 - Increasing the iteration</h3><p>迭代次数取决于可用的时间和资源。由<code>n_iter</code>定义。默认设置为10。增加迭代次数有可能提升调优后的模型性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tune model</span><br></pre></td></tr></table></figure>

<p><strong>10次和50次迭代的比较</strong></p>
<p><strong>n_iter &#x3D; 10</strong></p>
<p><img src="/images/PyCaret/image-tune_model-Increasing_the_iteration-10.png" alt="image-tune_model-Increasing_the_iteration-10"></p>
<p><strong>n_iter &#x3D; 50</strong></p>
<p><img src="/images/PyCaret/image-tune_model-Increasing_the_iteration-50.png" alt="image-tune_model-Increasing_the_iteration-50"></p>
<h3 id="5-3-选择度量方式-Choosing-the-metric"><a href="#5-3-选择度量方式-Choosing-the-metric" class="headerlink" title="5.3 选择度量方式 - Choosing the metric"></a>5.3 选择度量方式 - Choosing the metric</h3><p>当您调整模型的超参数时，您必须知道要针对哪个度量进行优化。可以在<code>optimize</code>参数下定义。默认情况下，对于分类任务，其设置为“<code>Accuracy </code>- 准确性”，对于回归，将其设置为“<code>R2</code>”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuned_dt = tune_model(dt, optimize = <span class="string">&#x27;MAE&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-tune_model-Choosing_the_metric.png" alt="tune_model-Choosing_the_metric"></p>
<h3 id="5-4-传递自定义网格-Passing-custom-grid"><a href="#5-4-传递自定义网格-Passing-custom-grid" class="headerlink" title="5.4 传递自定义网格 - Passing custom grid"></a>5.4 传递自定义网格 - Passing custom grid</h3><p>PyCaret已经为库中的所有模型定义了超参数的调整网格。但是，如果您愿意，可以通过使用<code>custom_grid</code>参数传递自定义网格来定义自己的搜索空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data </span><br><span class="line">boston = get_data(<span class="string">&#x27;boston&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.regression <span class="keyword">import</span> * </span><br><span class="line">reg1 = setup(boston, target = <span class="string">&#x27;medv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># train model</span></span><br><span class="line">dt = create_model(<span class="string">&#x27;dt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define search space</span></span><br><span class="line">params = &#123;<span class="string">&quot;max_depth&quot;</span>: np.random.randint(<span class="number">1</span>, (<span class="built_in">len</span>(boston.columns)*<span class="number">.85</span>),<span class="number">20</span>),</span><br><span class="line">          <span class="string">&quot;max_features&quot;</span>: np.random.randint(<span class="number">1</span>, <span class="built_in">len</span>(boston.columns),<span class="number">20</span>),</span><br><span class="line">          <span class="string">&quot;min_samples_leaf&quot;</span>: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]&#125;</span><br><span class="line">          </span><br><span class="line"><span class="comment"># tune model</span></span><br><span class="line">tuned_dt = tune_model(dt, custom_grid = params)</span><br></pre></td></tr></table></figure>

<h3 id="5-5-更改搜索算法-Changing-the-search-algorithm"><a href="#5-5-更改搜索算法-Changing-the-search-algorithm" class="headerlink" title="5.5 更改搜索算法 - Changing the search algorithm"></a>5.5 更改搜索算法 - Changing the search algorithm</h3><p>PyCaret与许多不同的库无缝集成，用于超参数调整。这使您可以访问许多不同类型的搜索算法，包括随机、贝叶斯、optuna、TPE等。所有这些都只需更改一个参数。默认情况下，PyCaret使用sklearn中的<code>RandomGridSearch</code>，您可以通过使用<code>tune_mode</code>函数中的<code>search_library</code>和<code>search_algorithm</code>参数来更改它。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tune model sklearn</span></span><br><span class="line">tune_model(dt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tune model optuna</span></span><br><span class="line">tune_model(dt, search_library = <span class="string">&#x27;optuna&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tune model scikit-optimize</span></span><br><span class="line">tune_model(dt, search_library = <span class="string">&#x27;scikit-optimize&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tune model tune-sklearn</span></span><br><span class="line">tune_model(dt, search_library = <span class="string">&#x27;tune-sklearn&#x27;</span>, search_algorithm = <span class="string">&#x27;hyperopt&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>搜索算法库 - search_library: str, default &#x3D; ‘scikit-learn’</p>
<ul>
<li><p>‘scikit-learn’：default, <a target="_blank" rel="noopener" href="https://github.com/scikit-learn/scikit-learn">https://github.com/scikit-learn/scikit-learn</a></p>
</li>
<li><p>‘scikit-optimize’：<a target="_blank" rel="noopener" href="https://scikit-optimize.github.io/stable/">https://scikit-optimize.github.io/stable/</a></p>
<p><code>pip install scikit-optimize</code></p>
</li>
<li><p>‘tune-sklearn’：<a target="_blank" rel="noopener" href="https://github.com/ray-project/tune-sklearn">https://github.com/ray-project/tune-sklearn</a></p>
</li>
</ul>
<p>  <code>pip install tune-sklearn ray[tune]</code></p>
<ul>
<li>‘optuna’：<a target="_blank" rel="noopener" href="https://optuna.org/">https://optuna.org/</a></li>
</ul>
<p>  <code>pip install optuna</code></p>
</li>
<li><p>搜索算法选择 -  search_algorithm: str, default &#x3D; None</p>
<blockquote>
<p>搜索算法取决于“search_library”参数。某些搜索算法需要安装额外的库。<br>If None，将使用搜索库特定的默认算法。</p>
</blockquote>
<ul>
<li>‘scikit-learn’ :<ul>
<li>‘random’ : 随机网络搜索 - random grid search (default)</li>
<li>‘grid’ : 网络搜索 - grid search</li>
</ul>
</li>
<li>‘scikit-optimize’:<ul>
<li>‘bayesian’ : 贝叶斯搜索 - Bayesian search (default)</li>
</ul>
</li>
<li>‘tune-sklearn’ possible values:<ul>
<li>‘random’ : 随机网络搜索 - random grid search (default)</li>
<li>‘grid’ : 网络搜索 - grid search</li>
<li>‘bayesian’ : <code>pip install scikit-optimize</code></li>
<li><code>&#39;hyperopt&#39; : </code>pip install hyperopt</li>
<li><code>&#39;optuna&#39; : </code>pip install optuna</li>
<li><code>&#39;bohb&#39; : </code>pip install hpbandster ConfigSpace</li>
</ul>
</li>
<li>‘optuna’ possible values:<ul>
<li>‘random’ : 随机搜索 - randomized search</li>
<li>‘tpe’ : 树结构Parzen估计搜索 - Tree-structured Parzen Estimator search (default)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-6-访问微调器-Access-the-tuner"><a href="#5-6-访问微调器-Access-the-tuner" class="headerlink" title="5.6 访问微调器 - Access the tuner"></a>5.6 访问微调器 - Access the tuner</h3><p>默认情况下，PyCaret的<code>tune_mode</code>函数只返回优化器选择的最佳模型。有时您可能需要访问tuner对象，因为它可能包含重要的属性，您可以使用<code>return_tuner</code>参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tune model and return tuner</span></span><br><span class="line">tuned_model, tuner = tune_model(dt, return_tuner=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(tuned_model), <span class="built_in">type</span>(tuner)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-tune_model-Access_the_tuner-1.png" alt="Access_the_tuner-1"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tuner)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-tune_model-Access_the_tuner-2.png" alt="Access_the_tuner-2"></p>
<h3 id="5-7-自动选择更好的模型-Automatically-choose-better"><a href="#5-7-自动选择更好的模型-Automatically-choose-better" class="headerlink" title="5.7 自动选择更好的模型 - Automatically choose better"></a>5.7 自动选择更好的模型 - Automatically choose better</h3><p>通常情况下，<code>tune_model</code>不会提高模型性能。事实上，它最终可能会使性能比具有默认超参数的模型更差。如果您没有在Notebook中积极进行实验，而是使用了运行<code>create_model</code>–&gt;<code>tune_mode</code>或<code>compare_models</code>–&gt;<code>tune_mode</code>工作流的python脚本，则这可能会产生问题。要解决这个问题，可以使用<code>choose_better</code>。当设置为<code>True</code>时，它将始终返回性能更好的模型，这意味着如果超参数调整不能提高性能，它将返回输入模型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tune model</span></span><br><span class="line">dt = tune_model(dt, choose_better = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：choose_better不会影响屏幕上显示的评分网格。评分网格将始终显示优化器选择的最佳模型的性能，不管输出性能是否小于输入性能。</p>
</blockquote>
<h3 id="5-8-集成模型-ensemble-model"><a href="#5-8-集成模型-ensemble-model" class="headerlink" title="5.8 集成模型 - ensemble_model()"></a>5.8 集成模型 - ensemble_model()</h3><p><code>ensemble_model()</code>函数在Pycaret中用于对多个模型进行集成，以期望提高模型的性能和泛化能力。模型集成是一种常见的机器学习技术，通过结合多个模型的预测结果来生成最终的预测。此函数返回一个表，该表具有k倍的通用评估指标的交叉验证分数以及训练后的模型对象。使用的评估指标是： 分类（准确性，AUC，召回率，精度，F1，Kappa，MCC）回归（MAE，MSE，RMSE，R2，RMSLE，MAPE）。</p>
<p>可以使用<code>ensemble_model()</code>函数中的fold参数定义折叠次数。默认情况下，折叠倍数设置为10，所有指标均四舍五入到4位小数，可以使用round参数进行更改。有两种可用于模型集成的方法，通过<code>method</code>参数设置。这两种方法都需要对数据进行重新采样并拟合多个估计量，因此可以使用<code>n_estimators</code>参数来控制估计量的数量。默认情况下，<code>n_estimators</code>设置为10。</p>
<blockquote>
<p>注意：该函数仅在pycaret.classification和pycaret.regression模块中可用。</p>
</blockquote>
<h4 id="Bagging-装袋算法"><a href="#Bagging-装袋算法" class="headerlink" title="Bagging - 装袋算法"></a>Bagging - 装袋算法</h4><p>Bagging，也称为Bootstrap aggregating，引导聚集算法，是一种机器学习集成元算法，旨在提高统计分类和回归中使用的机器学习算法的稳定性和准确性。 它还可以减少差异并有助于避免过度拟合。 尽管它通常应用于决策树方法，但可以与任何类型的方法一起使用。 套袋算法是模型平均方法的特例。</p>
<p><img src="/images/PyCaret/image-Optimize-ensemble_model-Bagging.png" alt="image-Optimize-ensemble_model-Bagging"></p>
<h4 id="Boosting-提升算法"><a href="#Boosting-提升算法" class="headerlink" title="Boosting - 提升算法"></a>Boosting - 提升算法</h4><p>Boosting是一种集成元算法，主要用于减少监督学习中的偏见和差异。 提升属于机器学习算法家族，可将弱学习者转化为强学习者。 弱学习者被定义为仅与真实分类略相关的分类器（它可以比随机猜测更好地标记示例）。 相反，学习能力强的分类器是与真实分类任意相关的分类器。</p>
<p><img src="/images/PyCaret/image-Optimize-ensemble_model-Bagging_and_Boosting.png" alt="image-Optimize-ensemble_model-Bagging_and_Boosting"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ensemble with bagging</span></span><br><span class="line">ensemble_model(rf, method = <span class="string">&#x27;Bagging&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-other-ensemble_model-1.png" alt="ensemble_model-1"></p>
<p>ensemble_model中非常有用的其他一些参数包括：</p>
<ul>
<li>choose_better：自动选择更好的模型 - <a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/optimize#automatically-choose-better-1">Automatically choose better</a></li>
<li>n_estimators：增加估算量 - <a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/optimize#increasing-the-estimators">Increasing the estimators</a></li>
<li>groups</li>
<li>fit_kwargs</li>
<li>return_train_score</li>
</ul>
<p>可以查看函数的文档字符串以了解更多信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span>(ensemble_model)</span><br></pre></td></tr></table></figure>

<h3 id="5-9-混合模型-blend-models"><a href="#5-9-混合模型-blend-models" class="headerlink" title="5.9 混合模型 - blend_models()"></a>5.9 混合模型 - blend_models()</h3><p>在Pycaret中，<code>blend_models()</code>函数用于将多个已训练的模型进行集成（blending）。它采用一种加权平均的方法，结合多个模型的预测结果来生成最终的预测。</p>
<p><code>blend_models()</code>函数的主要功能如下：</p>
<ol>
<li>模型集成：<code>blend_models()</code>函数接收多个已训练的模型对象作为输入，并将它们进行集成。这些模型可以是通过<code>compare_models()</code>或<code>create_model()</code>等函数训练和创建的。</li>
<li>加权平均：<code>blend_models()</code>函数使用加权平均的方法，根据每个模型的预测性能和权重来生成最终的预测结果。权重可以手动指定，也可以使用默认的均匀权重。</li>
<li>集成模型：<code>blend_models()</code>函数返回一个集成的模型对象，该模型对象包含了多个模型的组合。这个集成模型可以像单个模型一样进行预测操作。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best_mae_models_top3 = compare_models(sort = <span class="string">&#x27;MAE&#x27;</span>, n_select = <span class="number">3</span>)</span><br><span class="line"><span class="comment"># blend top 3 models</span></span><br><span class="line">blend_models(best_mae_models_top3)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-other-blend_models-1.png" alt="blend_models-1"></p>
<p>通过使用<code>blend_models()</code>函数，可以将多个模型的预测结果结合起来，以期望提高模型的性能和鲁棒性。</p>
<p>在blend_models中，您可能会发现其他一些非常有用的参数包括：</p>
<ul>
<li>choose_better - <a href="">Automatically choose better</a></li>
<li>weights - <a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/optimize#changing-the-weights">Changing the weights</a></li>
<li>optimize</li>
<li>fit_kwargs</li>
<li>return_train_score</li>
</ul>
<p>可以查看函数的文档字符串以了解更多信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span>(blend_models)</span><br></pre></td></tr></table></figure>

<h4 id="（1）动态输入估计器-Dynamic-input-estimators"><a href="#（1）动态输入估计器-Dynamic-input-estimators" class="headerlink" title="（1）动态输入估计器 - Dynamic input estimators"></a>（1）动态输入估计器 - <a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/optimize#dynamic-input-estimators">Dynamic input estimators</a></h4><p>您还可以使用<code>compare_models</code>函数自动生成输入估计量的列表。这样做的好处是，您根本不需要更改脚本。每次使用前N个模型作为输入列表时。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">diabetes = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># blend models</span></span><br><span class="line">blender = blend_models(compare_models(n_select = <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>注意这里发生的事情。我们将<code>compare_models(n_select = 3)</code>作为输入传递给<code>blend_models</code>。内部发生的情况是，首先执行<code>compare_modes</code>函数，然后将前3个模型作为输入传递到<code>blend_models</code>函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(blender)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-Optimize-blend_models-print(blender).png" alt="image-Optimize-blend_models-print(blender)"></p>
<h4 id="（2）混合方法-Changing-the-method"><a href="#（2）混合方法-Changing-the-method" class="headerlink" title="（2）混合方法 - Changing the method"></a>（2）混合方法 - <a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/optimize#changing-the-method">Changing the method</a></h4><blockquote>
<p>注意：方法参数仅在“分类”模块中可用。</p>
</blockquote>
<p>当<code>method = &#39;soft&#39;</code>时，它基于预测概率之和的argmax来预测类标签，推荐用于校准良好的分类器集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">diabetes = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># train a few models</span></span><br><span class="line">lr = create_model(<span class="string">&#x27;lr&#x27;</span>)</span><br><span class="line">dt = create_model(<span class="string">&#x27;dt&#x27;</span>)</span><br><span class="line">knn = create_model(<span class="string">&#x27;knn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># blend models</span></span><br><span class="line">blender_soft = blend_models([lr,dt,knn], method = <span class="string">&#x27;soft&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>当<code>method = &#39;hard&#39;</code>时，它使用输入模型的预测（硬标签），而不是概率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">diabetes = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># train a few models</span></span><br><span class="line">lr = create_model(<span class="string">&#x27;lr&#x27;</span>)</span><br><span class="line">dt = create_model(<span class="string">&#x27;dt&#x27;</span>)</span><br><span class="line">knn = create_model(<span class="string">&#x27;knn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># blend models</span></span><br><span class="line">blender_hard = blend_models([lr,dt,knn], method = <span class="string">&#x27;hard&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>默认方法设置为<code>auto</code>，这意味着它将优先尝试使用<code>soft</code>，如果不支持，则返回<code>hard</code>，当您的一个输入模型不支持<code>predict_proba</code>属性时，可能会发生这种情况。</p>
<h4 id="（3）改变权重-Changing-the-weights"><a href="#（3）改变权重-Changing-the-weights" class="headerlink" title="（3）改变权重 - Changing the weights"></a>（3）改变权重 - Changing the weights</h4><p>默认情况下，在混合所有输入模型时，它们的权重都是相等的，但您可以明确地将权重传递给每个输入模型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码片段 - blend models</span></span><br><span class="line">blender_weighted = blend_models([lr,dt,knn], weights = [<span class="number">0.5</span>,<span class="number">0.2</span>,<span class="number">0.3</span>])</span><br></pre></td></tr></table></figure>

<p>您也可以使用tune_mode来调整优化器的权重。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码片段 - blend models</span></span><br><span class="line">blender_weighted = blend_models([lr,dt,knn], weights = [<span class="number">0.5</span>,<span class="number">0.2</span>,<span class="number">0.3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码片段 - tune blender</span></span><br><span class="line">tuned_blender = tune_model(blender_weighted)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tuned_blender)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-Optimize-blend_models-Change_weights_print(tuned_blender).png" alt="image-Optimize-blend_models-Change_weights_print(tuned_blender)"></p>
<h3 id="5-10-堆叠模型-stack-models"><a href="#5-10-堆叠模型-stack-models" class="headerlink" title="5.10 堆叠模型 - stack_models()"></a>5.10 堆叠模型 - stack_models()</h3><p>在Pycaret中，<code>stack_models()</code>函数用于将多个已训练的模型进行堆叠（stacking）。堆叠是一种模型集成的技术，它通过将多个基础模型的预测结果作为输入，训练一个元模型来生成最终的预测。</p>
<p><code>stack_models()</code>函数的主要功能如下：</p>
<ol>
<li>模型堆叠：<code>stack_models()</code>函数接收多个已训练的模型对象作为输入，并将它们进行堆叠。这些模型可以是通过<code>compare_models()</code>或<code>create_model()</code>等函数训练和创建的。</li>
<li>元模型训练：<code>stack_models()</code>函数会使用一种堆叠的方法，在已有的模型预测结果的基础上，训练一个元模型。这个元模型可以是线性回归、随机森林等机器学习算法，用于组合基础模型的预测结果。</li>
<li>特征选择：<code>stack_models()</code>函数还会自动进行特征选择，选择在堆叠中最具有预测能力的特征子集，以提高模型的性能。</li>
<li>集成模型：<code>stack_models()</code>函数返回一个堆叠的模型对象，该模型对象包含了多个基础模型和一个元模型的组合。这个堆叠模型可以像单个模型一样进行预测操作。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># stack models</span></span><br><span class="line">stack_models(best_mae_models_top3)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-other-stack_models-1.png" alt="stack_models-1"></p>
<p>通过使用<code>stack_models()</code>函数，可以将多个模型的预测结果结合起来，并使用元模型对它们进行进一步的组合和调整，以期望提高模型的性能和泛化能力。</p>
<p>stack_models中非常有用的其他一些参数包括：</p>
<ul>
<li>method - <a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/optimize#changing-the-method-1">Changing the method</a></li>
<li>choose_better - </li>
<li>meta_model - <a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/optimize#changing-the-meta-model">Changing the meta-model</a></li>
<li>restack - <a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/optimize#restacking">Restacking</a></li>
<li>optimize - <a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/optimize#optimize_threshold">optimize_threshold</a></li>
<li>return_train_score</li>
</ul>
<p>可以查看函数的文档字符串以了解更多信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span>(stack_models)</span><br></pre></td></tr></table></figure>

<p>在Pycaret中，<code>stack_models()</code>和<code>blend_models()</code>是用于模型集成的两个不同函数，它们具有以下区别：</p>
<ol>
<li><p>集成方式：<code>stack_models()</code>函数使用堆叠（stacking）的方式进行模型集成，而<code>blend_models()</code>函数使用混合（blending）的方式进行模型集成。</p>
</li>
<li><p>模型组合：<code>stack_models()</code>函数将多个基础模型的预测结果作为输入，训练一个元模型来生成最终的预测。它通过在已有的模型预测结果的基础上进行进一步的组合和调整，以提高模型的性能。</p>
<p><code>blend_models()</code>函数直接将多个训练好的模型进行集成，使用加权平均的方法（soft voting）或简单平均的方法（hard voting）生成最终的预测结果。</p>
</li>
<li><p>数据使用：<code>stack_models()</code>函数使用训练集和验证集进行堆叠，它将基础模型在验证集上的预测结果作为元特征（meta-feature）输入给元模型进行训练。</p>
<p><code>blend_models()</code>函数使用训练集进行模型训练，然后使用训练好的模型直接对新数据进行预测，不需要额外的验证集。</p>
</li>
<li><p>结果解释：<code>stack_models()</code>函数提供了对模型性能的更详细解释，因为它基于基础模型在验证集上的预测结果进行元模型的训练和组合。</p>
<p><code>blend_models()</code>函数提供了更简单的集成结果，它只是对多个模型的预测结果进行平均或投票，不需要进一步解释模型的性能。</p>
</li>
</ol>
<p>选择使用<code>stack_models()</code>还是<code>blend_models()</code>取决于数据集和任务的特点以及对模型集成的需求。如果希望通过更复杂的堆叠方式获得更好的性能提升，并且愿意使用额外的验证集进行训练，可以选择<code>stack_models()</code>。如果希望使用简单而直接的模型集成方法，并且不需要额外的验证集，可以选择<code>blend_models()</code>。</p>
<p>在实践中，可以尝试使用这两个函数并比较它们的性能，以选择最适合特定问题的模型集成方法。</p>
<p><strong>堆叠和混合区别：</strong></p>
<p>堆叠（Stacking）和混合（Blending）是两种常见的模型集成技术，用于将多个模型的预测结果进行组合以获得更好的性能。它们有以下区别：</p>
<ol>
<li>数据使用：<ul>
<li>堆叠：堆叠使用训练集和验证集进行模型集成。首先，基础模型在训练集上进行训练，并在验证集上生成预测结果。然后，这些预测结果被作为元特征输入给元模型（也称为次级模型或元学习器），进一步训练元模型来生成最终的预测结果。</li>
<li>混合：混合使用训练集进行模型训练，并直接在新数据上生成预测结果。多个训练好的模型的预测结果通过加权平均（软投票）或简单平均（硬投票）的方式进行组合，生成最终的预测结果。</li>
</ul>
</li>
<li>结果解释：<ul>
<li>堆叠：堆叠提供了对模型性能的更详细解释。由于堆叠包括了基础模型的预测结果作为元特征，通过元模型的训练和组合，可以进一步改进模型的性能。堆叠可以捕捉到不同模型之间的差异和互补性。</li>
<li>混合：混合提供了更简单的集成结果。它只是将多个模型的预测结果进行平均或投票，而不需要进一步解释模型的性能。</li>
</ul>
</li>
<li>训练过程：<ul>
<li>堆叠：堆叠需要两个步骤，首先是基础模型的训练，然后是元模型的训练。需要在训练集和验证集上进行多次模型训练和预测。</li>
<li>混合：混合只需要进行一次基础模型的训练，并在训练集上生成预测结果。然后，可以直接在新数据上使用训练好的模型进行预测。</li>
</ul>
</li>
<li>集成结果：<ul>
<li>堆叠：堆叠使用基础模型的预测结果作为元特征，并通过元模型对这些特征进行进一步的训练和组合。最终的集成结果来自元模型的预测结果。</li>
<li>混合：混合直接将多个模型的预测结果进行组合，生成最终的集成预测结果。</li>
</ul>
</li>
</ol>
<h3 id="5-11-校准模型-calibrate-model"><a href="#5-11-校准模型-calibrate-model" class="headerlink" title="5.11 校准模型 - calibrate_model"></a>5.11 校准模型 - calibrate_model</h3><p>该函数使用等渗回归或逻辑回归(isotonic or logistic regression)来校准给定模型的概率。此函数的输出是一个按倍数显示CV分数的评分网格。可以使用<code>get_Metrics</code>函数访问CV期间评估的度量。可以使用<code>add_metric</code>和<code>remove_metric</code>函数添加或删除自定义度量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">diabetes = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># train a model</span></span><br><span class="line">dt = create_model(<span class="string">&#x27;dt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># calibrate model</span></span><br><span class="line">calibrated_dt = calibrate_model(dt)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(calibrated_dt)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-Optimize-blend_models-Change_weights_print(tuned_blender)-1714019259721.png" alt="image-Optimize-blend_models-Change_weights_print(tuned_blender)"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/optimize#before-and-after-calibration">Before and after calibration</a></p>
</blockquote>
<h2 id="6-Analyze-模型分析与绘制-plot-model"><a href="#6-Analyze-模型分析与绘制-plot-model" class="headerlink" title="6. Analyze-模型分析与绘制-plot_model"></a>6. Analyze-模型分析与绘制-<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/analyze#plot_model">plot_model</a></h2><p><img src="/images/PyCaret/PyCaret-workflow-6.jpg" alt="PyCaret-workflow-6"></p>
<p><code>plot_model()</code>函数是Pycaret库中用于绘制模型相关图表的函数。它可以根据提供的参数绘制不同类型的图表来帮助分析和可视化模型的性能和结果。</p>
<p>下面是<code>plot_model()</code>函数中的<code>plot</code>参数的可选值和对应的图表类型：</p>
<ul>
<li><code>&#39;pipeline&#39;</code>：预处理流程图</li>
<li><code>&#39;residuals_interactive&#39;</code>：交互式残差图</li>
<li><code>&#39;residuals&#39;</code>：残差图</li>
<li><code>&#39;error&#39;</code>：预测误差图</li>
<li><code>&#39;cooks&#39;</code>：Cook’s距离图</li>
<li><code>&#39;rfe&#39;</code>：递归特征选择图</li>
<li><code>&#39;learning&#39;</code>：学习曲线</li>
<li><code>&#39;vc&#39;</code>：验证曲线</li>
<li><code>&#39;manifold&#39;</code>：流形学习图</li>
<li><code>&#39;feature&#39;</code>：特征重要性图</li>
<li><code>&#39;feature_all&#39;</code>：所有特征的特征重要性图</li>
<li><code>&#39;parameter&#39;</code>：模型超参数图</li>
<li><code>&#39;tree&#39;</code>：决策树图</li>
</ul>
<p>通过选择适当的<code>plot</code>参数值，您可以生成所需类型的图表来更好地理解和评估模型的性能和特征重要性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_model(best_model,plot=<span class="string">&#x27;residuals_interactive&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-plot-residuals_interactive-1.png" alt="plot-residuals_interactive"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_model(best_model,plot=<span class="string">&#x27;residuals&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-plot-residuals.png" alt="plot-residuals"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_model(rf,plot=<span class="string">&#x27;feature&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-plot-feature.png" alt="plot-feature"></p>
<h3 id="6-1-plot绘图参数调整"><a href="#6-1-plot绘图参数调整" class="headerlink" title="6.1 plot绘图参数调整"></a>6.1 plot绘图参数调整</h3><h4 id="（1）更改绘图比例-Change-the-scale"><a href="#（1）更改绘图比例-Change-the-scale" class="headerlink" title="（1）更改绘图比例 - Change the scale"></a>（1）更改绘图比例 - <strong>Change the scale</strong></h4><p>图形的分辨率比例可以通过<code>scale</code>参数进行更改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">diabetes = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating a model</span></span><br><span class="line">lr = create_model(<span class="string">&#x27;lr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot model</span></span><br><span class="line">plot_model(lr, plot = <span class="string">&#x27;auc&#x27;</span>, scale = <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-Analyze-plot-change_the_scale.png" alt="image-Analyze-plot-change_the_scale"></p>
<h4 id="（2）保存绘图-Save-the-plot"><a href="#（2）保存绘图-Save-the-plot" class="headerlink" title="（2）保存绘图 - Save the plot"></a>（2）保存绘图 - Save the plot</h4><p>可以使用<code>save</code>参数将打印另存为png文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码片段 - plot model</span></span><br><span class="line">plot_model(lr, plot = <span class="string">&#x27;auc&#x27;</span>, save = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-Analyze-plot-save_the_plot.png" alt="image-Analyze-plot-save_the_plot"></p>
<h4 id="（3）自定义绘图-Customize-the-plot"><a href="#（3）自定义绘图-Customize-the-plot" class="headerlink" title="（3）自定义绘图 - Customize the plot"></a>（3）自定义绘图 - Customize the plot</h4><p>PyCaret在大多数绘图中使用<a target="_blank" rel="noopener" href="https://www.scikit-yb.org/en/latest/">Yellowbrick</a>。任何Yellowbrink可视化工具可接受的参数都可以作为<code>plot_kwargs</code>参数传递。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">diabetes = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating a model</span></span><br><span class="line">lr = create_model(<span class="string">&#x27;lr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot model</span></span><br><span class="line">plot_model(lr, plot = <span class="string">&#x27;confusion_matrix&#x27;</span>, plot_kwargs = &#123;<span class="string">&#x27;percent&#x27;</span> : <span class="literal">True</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-Analyze-plot-Customize_the_plot.png" alt="image-Analyze-plot-Customize_the_plot"></p>
<blockquote>
<p>tab blog</p>
</blockquote>
<h4 id="（4）使用训练集数据-Use-train-data"><a href="#（4）使用训练集数据-Use-train-data" class="headerlink" title="（4）使用训练集数据 - Use train data"></a>（4）使用训练集数据 - Use train data</h4><p>如果要评估列车数据上的模型图，可以在<code>plot_mode</code>函数中传递<code>use_train_data=True</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># plot model</span></span><br><span class="line">plot_model(lr, plot = <span class="string">&#x27;auc&#x27;</span>, use_train_data = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tab blog - Plot on train data vs. hold-out data</p>
</blockquote>
<h4 id="（5）可用的绘图类型-Examples-by-module"><a href="#（5）可用的绘图类型-Examples-by-module" class="headerlink" title="（5）可用的绘图类型 - Examples by module"></a>（5）可用的绘图类型 - <strong><a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/analyze#examples-by-module">Examples by module</a></strong></h4><blockquote>
<p>暂不描述</p>
</blockquote>
<h3 id="6-2-汇总-模型评估-evaluate-model"><a href="#6-2-汇总-模型评估-evaluate-model" class="headerlink" title="6.2 汇总-模型评估 - evaluate_model"></a>6.2 汇总-模型评估 - <a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/analyze#evaluate_model">evaluate_model</a></h3><p><img src="/images/PyCaret/PyCaret-workflow-7.jpg" alt="PyCaret-workflow-7"></p>
<p>分析模型性能的另一种方法是使用<code>evaluate_model()</code>函数，该函数显示给定模型的所有可用图形的用户界面。在内部它使用<code>plot_model()</code>函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">evaluate_model(best_model)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-evaluate_model-1.png" alt="evaluate_model-1"></p>
<h2 id="7-Analyze-解释模型-interpret-model"><a href="#7-Analyze-解释模型-interpret-model" class="headerlink" title="7. Analyze-解释模型-interpret_model"></a>7. Analyze-解释模型-<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/analyze#interpret_model">interpret_model</a></h2><h3 id="7-1-可解释性模型-interpret-model"><a href="#7-1-可解释性模型-interpret-model" class="headerlink" title="7.1 可解释性模型 - interpret_model"></a>7.1 可解释性模型 - interpret_model</h3><blockquote>
<p>&#x3D;&#x3D;todo&#x3D;&#x3D; 该部分的内容还有待进一步完善</p>
</blockquote>
<p>在Pycaret的<code>interpret_model()</code>函数中，可以使用不同的绘图属性（plot_type）来生成不同类型的解释图表。基于<a target="_blank" rel="noopener" href="https://shap.readthedocs.io/en/latest/">SHAP（SHapley加法解释）</a>实现，以下是常用的解释图表类型和对应的绘图属性：</p>
<ol>
<li>‘summary’：基于SHAP生成模型的摘要图表。该图表显示了每个特征对于预测的贡献程度，以及特征的重要性排序。</li>
<li>‘correlation’：基于SHAP生成相关性图（Correlation）。该图表显示了特征与模型预测之间的关系，可以帮助理解特征如何影响预测结果。</li>
<li>‘reason’：基于SHAP生成力图（Reason Plot）。力图展示了单个样本的特征对预测结果的影响，可以帮助解释单个样本的预测原因。</li>
<li>‘pdp’：生成部分依赖图（Partial Dependence Plot）。部分依赖图显示了特定特征在其他特征固定的情况下，对预测结果的影响。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># interpret model</span></span><br><span class="line">interpret_model(xgboost, plot = <span class="string">&#x27;pdp&#x27;</span>, feature = <span class="string">&#x27;Age (years)&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>‘msa’：执行Morris敏感性分析（Morris Sensitivity Analysis），用于评估模型中各个特征对输出的敏感性。</p>
</li>
<li><p>‘pfi’：执行排列特征重要性（Permutation Feature Importance）分析，用于确定特征对模型预测的重要性排序。</p>
</li>
</ol>
<p>这些解释图表可以帮助理解模型的特征重要性、特征对预测的影响、特征之间的相关性等，从而提供对模型的解释和理解。根据需要，可以选择适合问题的解释图表类型，并通过调整参数来定制图表的输出。</p>
<blockquote>
<p>前三个函数只支持这些模型: catboost, xgboost, lightgbm, rf, et, dt.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rf=create_model(<span class="string">&#x27;rf&#x27;</span>)</span><br><span class="line">interpret_model(rf, plot = <span class="string">&#x27;summary&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-interpret_model-summary-rf.png" alt="interpret_model-summary-rf"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">interpret_model(rf, plot = <span class="string">&#x27;correlation&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-interpret_model-correlation.png" alt="interpret_model-correlation"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">diabetes = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating a model</span></span><br><span class="line">xgboost = create_model(<span class="string">&#x27;xgboost&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># interpret model</span></span><br><span class="line">interpret_model(xgboost, plot = <span class="string">&#x27;reason&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-Analyze-interpret_model-reason_plot.png" alt="image-Analyze-interpret_model-reason_plot"></p>
<p>当您在不通过测试数据的特定索引的情况下生成原因图时，将获得显示的交互式图，并能够选择x轴和y轴。只有当您使用Jupyter Notebook或同等环境时，这才可能实现。如果要查看特定观测的此图，则必须传递观测参数中的索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">interpret_model(rf, plot = <span class="string">&#x27;reason&#x27;</span>, observation = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-interpret_model-reason.png" alt="interpret_model-reason"></p>
<h4 id="（1）保存绘图-Save-the-plot"><a href="#（1）保存绘图-Save-the-plot" class="headerlink" title="（1）保存绘图 - Save the plot"></a>（1）保存绘图 - Save the plot</h4><p>可以使用<code>save</code>参数将打印另存为<code>png</code>文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># interpret model</span></span><br><span class="line">interpret_model(xgboost, save = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="（2）使用训练集数据-Use-train-data"><a href="#（2）使用训练集数据-Use-train-data" class="headerlink" title="（2）使用训练集数据 - Use train data"></a>（2）使用训练集数据 - Use train data</h4><p>默认情况下，所有绘图都是在测试数据集上生成的。如果要使用训练数据集（不推荐）生成绘图，可以使用<code>use_train_data</code>参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># interpret model</span></span><br><span class="line">interpret_model(xgboost, use_train_data = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-2-公平性检验-check-fairness"><a href="#7-2-公平性检验-check-fairness" class="headerlink" title="7.2 公平性检验 - check_fairness"></a>7.2 公平性检验 - check_fairness</h3><p>公平概念化有多种方法。<code>check_fairness</code>函数遵循被称为群体公平的方法，该方法询问：群体中哪些个体更易收到经验伤害的风险。<code>check_fairness</code>提供不同组（也称为子群体）之间的公平性相关度量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">income = get_data(<span class="string">&#x27;income&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">exp_name = setup(data = income,  target = <span class="string">&#x27;income &gt;50K&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># train model</span></span><br><span class="line">lr = create_model(<span class="string">&#x27;lr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># check model fairness</span></span><br><span class="line">lr_fairness = check_fairness(lr, sensitive_features = [<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;race&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-Analyze-check_fairness.png" alt="image-Analyze-check_fairness"></p>
<h2 id="8-Deploy-模型预测-predict-model"><a href="#8-Deploy-模型预测-predict-model" class="headerlink" title="8. Deploy-模型预测-predict_model"></a>8. Deploy-模型预测-<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/deploy#predict_model">predict_model</a></h2><p><img src="/images/PyCaret/PyCaret-workflow-9.png" alt="PyCaret-workflow-9"></p>
<p>在最终确定模型之前，建议通过预测测试和查看评估指标来执行最终检查。如果你查看信息表，你将看到20%的数据被分离为测试集样本。</p>
<p>我们在上面看到的所有评估指标大部分都是基于训练集(80%)的交叉验证结果。现在，使用存储在tuned_rf变量中的最终训练模型，我们根据测试样本进行预测，并评估指标，看它们是否与CV结果有实质性差异</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predict_model(et)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-predict_model-1.png" alt="predict_model-1"></p>
<p><img src="/images/PyCaret/image-predict_model-2.png" alt="predict_model-2"></p>
<p>可以看出示例数据中与之前训练的结果差异，测试集的MAE为0.0337，训练集的MAE为0.0348，其他精度的差距也没有显著区别。如果测试集和训练集的结果之间存在较大差异，这通常表示过拟合，但也可能是由于其他几个因素造成的，需要进一步调查。</p>
<p>在新的数据上进行预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># predict on new data</span></span><br><span class="line">new_data = diabetes.copy()</span><br><span class="line">new_data.drop(<span class="string">&#x27;Class variable&#x27;</span>, axis = <span class="number">1</span>, inplace = <span class="literal">True</span>)</span><br><span class="line">new_pred_data = predict_model(xgboost, data = new_data)</span><br></pre></td></tr></table></figure>

<h2 id="9-Deploy-确定最终模型-finalize-model"><a href="#9-Deploy-确定最终模型-finalize-model" class="headerlink" title="9. Deploy-确定最终模型-finalize_model"></a>9. Deploy-确定最终模型-<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/deploy#finalize_model">finalize_model</a></h2><p><img src="/images/PyCaret/PyCaret-workflow-8.png" alt="PyCaret-workflow-8"></p>
<p>确定最终模型是实验的最后一步。PyCaret中的正常机器学习工作流从<code>setup()</code>开始，然后使用<code>compare_models()</code>对所有模型进行比较，并预先选择一些候选模型(基于感兴趣的度量)，以执行各种建模技术，如超参数拟合、装配、堆叠等。</p>
<p><code>finalize_model()</code>函数使模型拟合完整的数据集，包括测试样本(在本例中为20%)。此函数的目的是在将模型部署到生产环境之前，对模型进行完整的数据集训练。我们可以在<code>predict_model()</code>之后或之前执行此方法。我们要在这之后执行。</p>
<blockquote>
<p>&#x3D;&#x3D;注意&#x3D;&#x3D;：使用<code>finalize_model()</code>完成模型后，整个数据集(包括测试集)将用于训练。因此，在<code>finalize_model()</code>之后使用模型对测试集进行预测，打印的信息网格将产生误导，因为它试图对用于建模的相同数据进行预测。（先使用<code>finalize_model()</code>后再使用<code>predict_model()</code>会造成数据过拟合，因为<code>finalize_model()</code>将所有数据包括测试集和训练集都拿去训练了。）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">final = finalize_model(best_model)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-finalize_model.png" alt="finalize_model"></p>
<p>使用<code>finalize_model()</code>函数对模型进行最终化之后，通常会将其用于新数据的预测。</p>
<p>然而，如果在对模型进行最终化之后再次使用<code>predict_model()</code>函数，可能会导致潜在的问题。这是因为<code>finalize_model()</code>函数在内部对模型进行了最后的拟合和调优，以便在整个训练集上获得最佳性能。因此，如果再次使用<code>predict_model()</code>函数，实际上会再次对已经最终化的模型进行拟合，这可能会导致过拟合或无效的结果。</p>
<h2 id="10-Deploy-保存-加载模型-save-load-model"><a href="#10-Deploy-保存-加载模型-save-load-model" class="headerlink" title="10. Deploy-保存&#x2F;加载模型-save&#x2F;load_model"></a>10. Deploy-保存&#x2F;加载模型-save&#x2F;load_model</h2><p><img src="/images/PyCaret/PyCaret-workflow-10.png" alt="workflow-10"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/functions/deploy#deploy_model">在云端部署模型 - deploy_model</a>: AWS、GCP、Azure</p>
</blockquote>
<h3 id="10-1-保存模型-save-model"><a href="#10-1-保存模型-save-model" class="headerlink" title="10.1 保存模型 - save_model"></a>10.1 保存模型 - save_model</h3><p>在Pycaret中，<code>save_model()</code>函数用于将训练和最终化的模型保存到磁盘上，以便以后在不同的环境中使用、加载和部署模型。</p>
<p><code>save_model()</code>函数的主要功能如下：</p>
<ol>
<li>模型保存：<code>save_model()</code>函数接收训练和最终化的模型对象，并将其保存到磁盘上的指定位置。模型可以保存为特定格式的文件，以便在以后的任务中加载和使用。</li>
<li>模型文件格式：Pycaret支持将模型保存为不同的文件格式，如pickle文件（.pkl）、Joblib文件（.joblib）等。这些文件格式是常见的机器学习模型保存和加载的标准格式。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">save_model(final, <span class="string">&#x27;pycaret_model1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-save_model.png" alt="save_model"></p>
<p>这个模型对象是一个<code>Pipeline</code>对象，其中包含了一系列的数据预处理步骤和最终的模型。下面是对该模型中部分对象的解释：</p>
<ol>
<li><code>numerical_imputer</code>（数值型特征填补）：使用<code>SimpleImputer</code>进行数值型特征（’GR’, ‘NPHI’, ‘RD’）的缺失值填补。</li>
<li><code>categorical_imputer</code>（分类特征填补）：使用<code>SimpleImputer</code>进行分类特征的缺失值填补，策略为使用最频繁的值进行填补。</li>
<li><code>normalize</code>（归一化）：使用<code>StandardScaler</code>进行数据的归一化处理。</li>
<li><code>actual_estimator</code>（最终的估计器）：使用<code>ExtraTreesRegressor</code>作为最终的回归模型，使用了全部可用的CPU核心（<code>n_jobs=-1</code>），并设定了随机种子为42。</li>
</ol>
<p>整个模型对象被保存为一个pickle文件（.pkl），文件名为 <code>&#39;pycaret_model1.pkl&#39;</code>。</p>
<h3 id="10-2-加载模型-load-model"><a href="#10-2-加载模型-load-model" class="headerlink" title="10.2 加载模型 - load_model"></a>10.2 加载模型 - load_model</h3><p>要在同一环境或其他环境中加载在将来某个日期保存的模型，我们将使用PyCaret的<code>load_model()</code>函数，然后轻松地将保存的模型应用到新的未查看的数据中以进行预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ml_model=load_model(<span class="string">&#x27;pycaret_model1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-load_model.png" alt="load_model"></p>
<p>一旦模型加载到环境中，就可以使用相同的predict_model()函数来预测任何新数据。接下来，我们应用加载模型来预测新数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df2 = pd.read_csv(<span class="string">&#x27;aligned_well_02_1_strech_1.csv&#x27;</span>)</span><br><span class="line">prediction=predict_model(ml_model, data=df2)</span><br><span class="line">prediction</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-predict_model.png" alt="predict_model"></p>
<h3 id="10-3-保存实验设置-save-experiment"><a href="#10-3-保存实验设置-save-experiment" class="headerlink" title="10.3 保存实验设置 - save_experiment"></a>10.3 保存实验设置 - save_experiment</h3><p><code>save_experiment</code>函数将实验保存到pickle文件中。该实验是使用cloudpickle来处理lambda函数来保存的。数据或测试数据不与实验一起保存，使用<code>load_experiment</code>加载时需要再次指定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">diabetes = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data = diabetes, target = <span class="string">&#x27;Class variable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># save experiment</span></span><br><span class="line">save_experiment(<span class="string">&#x27;my_saved_experiment1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="10-4-读取实验设置-load-experiment"><a href="#10-4-读取实验设置-load-experiment" class="headerlink" title="10.4 读取实验设置 - load_experiment"></a>10.4 读取实验设置 - load_experiment</h3><p>load_experiment函数从路径或文件加载实验。数据（和test_data）不与实验一起保存，需要在加载时再次指定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load data</span></span><br><span class="line">data = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># load experiment function</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> load_experiment</span><br><span class="line">clf2 = load_experiment(<span class="string">&#x27;my_saved_experiment1&#x27;</span>, data = data)</span><br></pre></td></tr></table></figure>

<h2 id="11-其他参数与设置"><a href="#11-其他参数与设置" class="headerlink" title="11. 其他参数与设置"></a>11. 其他参数与设置</h2><blockquote>
<p>todo 还有一些内容和参数没有添加</p>
</blockquote>
<h3 id="11-1-pull-返回最后打印的得分网格"><a href="#11-1-pull-返回最后打印的得分网格" class="headerlink" title="11.1 pull() - 返回最后打印的得分网格"></a>11.1 pull() - 返回最后打印的得分网格</h3><p>返回最后打印的得分网格。在任何训练函数之后使用<code>pull</code>函数将得分网格存储在<code>panda.DataFrame</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># loading dataset</span></span><br><span class="line"><span class="keyword">from</span> pycaret.datasets <span class="keyword">import</span> get_data</span><br><span class="line">data = get_data(<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init setup</span></span><br><span class="line"><span class="keyword">from</span> pycaret.classification <span class="keyword">import</span> *</span><br><span class="line">clf1 = setup(data, target = <span class="string">&#x27;Class variable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># compare models</span></span><br><span class="line">best_model = compare_models()</span><br><span class="line"></span><br><span class="line"><span class="comment"># get the scoring grid</span></span><br><span class="line">results = pull()</span><br></pre></td></tr></table></figure>

<p><em>输出的图片，略</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(results)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; pandas.core.frame.DataFrame</span></span><br></pre></td></tr></table></figure>

<h3 id="11-2-get-config-获取配置信息"><a href="#11-2-get-config-获取配置信息" class="headerlink" title="11.2 get_config() - 获取配置信息"></a>11.2 get_config() - 获取配置信息</h3><p>在Pycaret中，<code>get_config()</code>函数用于获取当前Pycaret会话的配置信息。它返回一个字典，其中包含Pycaret当前会话的各种配置选项和参数。</p>
<p><code>get_config()</code>函数的主要功能如下：</p>
<ol>
<li>获取配置信息：<code>get_config()</code>函数可以获取Pycaret当前会话的各种配置信息，包括数据预处理选项、模型训练选项、特征工程选项、交叉验证选项等。</li>
<li>配置参数：返回的字典中的键值对表示不同的配置参数。可以通过访问相应的键来获取特定的配置参数值。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">get_config()</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-other-get_config.png" alt="get_config"></p>
<ul>
<li><code>USI</code>：用户自定义标识符，用于跟踪和标识特定实验的用户自定义标识符。</li>
<li><code>X</code>：原始特征（输入变量）。</li>
<li><code>X_test</code>：测试集中的特征。</li>
<li><code>X_test_transformed</code>：经过预处理和转换后的测试集特征。</li>
<li><code>X_train</code>：训练集中的特征。</li>
<li><code>X_train_transformed</code>：经过预处理和转换后的训练集特征。</li>
<li><code>X_transformed</code>：经过预处理和转换后的特征（整个数据集）。</li>
<li><code>data</code>：原始数据集。</li>
<li><code>exp_id</code>：实验的唯一标识符。</li>
<li><code>exp_name_log</code>：用于记录实验的名称。</li>
<li><code>fold_generator</code>：用于生成交叉验证折叠的方法。</li>
<li><code>log_plots_param</code>：用于配置记录图表的参数。</li>
<li><code>n_jobs_param</code>：配置Pycaret中任务执行的CPU核心数量。</li>
<li><code>pipeline</code>：预处理和模型训练的管道。</li>
<li><code>seed</code>：随机种子，用于控制随机性。</li>
<li><code>target_param</code>：目标变量（预测变量）。</li>
<li><code>test</code>：测试集。</li>
<li><code>test_transformed</code>：经过预处理和转换后的测试集。</li>
<li><code>train</code>：训练集。</li>
<li><code>train_transformed</code>：经过预处理和转换后的训练集。</li>
<li><code>y</code>：原始目标变量（预测变量）。</li>
<li><code>y_test</code>：测试集中的目标变量。</li>
<li><code>y_test_transformed</code>：经过预处理和转换后的测试集目标变量。</li>
<li><code>y_train</code>：训练集中的目标变量。</li>
<li><code>y_train_transformed</code>：经过预处理和转换后的训练集目标变量。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">config =get_config(<span class="string">&#x27;X_test_transformed&#x27;</span>)</span><br><span class="line">config</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-other-get_config-2.png" alt="get_config-2"></p>
<p>在上面的示例中，首先使用<code>setup()</code>函数初始化分类任务，并根据需要进行了其他的Pycaret配置。然后，通过<code>get_config()</code>函数获取当前Pycaret会话的配置信息，并将其存储在<code>config</code>变量中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lets check the X_train_transformed to see effect of params passed</span></span><br><span class="line">get_config(<span class="string">&#x27;X_train_transformed&#x27;</span>)[<span class="string">&#x27;GR&#x27;</span>].hist()</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-other-get_config-3.png" alt="get_config-3"></p>
<p>使用<code>set_config</code>可以设置全局参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># reset environment seed</span></span><br><span class="line">set_config(<span class="string">&#x27;seed&#x27;</span>, <span class="number">999</span>)</span><br></pre></td></tr></table></figure>

<h3 id="11-3-get-leaderboard-获取排行榜"><a href="#11-3-get-leaderboard-获取排行榜" class="headerlink" title="11.3 get_leaderboard() - 获取排行榜"></a>11.3 get_leaderboard() - 获取排行榜</h3><p>在Pycaret中，<code>get_leaderboard()</code>函数用于获取模型的排行榜，按照性能指标对训练的多个模型进行排序并显示。它提供了一个简洁的方式来比较和评估不同模型的性能。</p>
<p>模型排行榜显示了不同模型在选择的性能指标上的得分。可以根据排行榜的结果来选择最佳模型或进一步分析模型的性能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get leaderboard</span></span><br><span class="line">lb = get_leaderboard()</span><br><span class="line">lb</span><br></pre></td></tr></table></figure>

<img src="images/PyCaret/image-other-get_leaderboard.png" alt="get_leaderboard" style="zoom:80%;" />

<p>get_leaderboard中非常有用的其他一些参数包括：</p>
<ul>
<li>finalize_models</li>
<li>fit_kwargs</li>
<li>model_only</li>
<li>groups</li>
</ul>
<p>可以查看函数的文档字符串以了解更多信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span>(get_leaderboard)</span><br></pre></td></tr></table></figure>

<p>可以通过该方式获得训练的工作流</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># check leaderboard</span></span><br><span class="line">lb = get_leaderboard()</span><br><span class="line"></span><br><span class="line"><span class="comment"># select top model</span></span><br><span class="line">lb.iloc[<span class="number">0</span>][<span class="string">&#x27;Model&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="11-4-automl"><a href="#11-4-automl" class="headerlink" title="11.4 automl()"></a>11.4 automl()</h3><p>此函数根据优化参数返回当前设置中所有训练模型中的最佳模型。可以使用get_Metrics函数访问评估的度量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find best model based on CV metrics</span></span><br><span class="line">automl()</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-other-automl.png" alt="automl"></p>
<h3 id="11-5-dashboard"><a href="#11-5-dashboard" class="headerlink" title="11.5 dashboard()"></a>11.5 dashboard()</h3><p>ExplainerDashboard是一个用于解释机器学习模型的Python库和工具，它提供了一个交互式仪表板，用于可视化和解释模型的预测结果、特征重要性和模型行为。</p>
<p>ExplainerDashboard 的主要功能包括：</p>
<ol>
<li>模型解释：ExplainerDashboard 可以帮助用户解释和理解机器学习模型的预测结果。它提供了多种图表和可视化工具，用于分析特征重要性、预测误差、决策边界等方面。</li>
<li>特征重要性：ExplainerDashboard 可以显示模型中各个特征的重要性和影响程度。通过可视化工具，用户可以了解每个特征对于模型预测的贡献程度，并比较不同特征之间的重要性。</li>
<li>预测解释：ExplainerDashboard 可以帮助用户解释和理解单个样本的预测结果。用户可以通过仪表板中的工具，深入分析每个特征对于某个样本的影响，并探索样本预测的原因和解释。</li>
<li>模型比较：ExplainerDashboard 可以同时显示多个模型的解释结果，帮助用户比较和对比不同模型的性能和解释。用户可以在仪表板中选择不同的模型，并观察它们的预测结果和特征重要性。</li>
</ol>
<p>ExplainerDashboard 是一个灵活且易于使用的工具，可应用于各种机器学习任务和模型类型。它提供了可视化和交互式的解释功能，使用户能够更好地理解和解释模型的行为和预测结果。通过使用 ExplainerDashboard，用户可以增加对模型的信任和理解，并从中获取有价值的见解。</p>
<p>目前的版本提供了5个tab，包括</p>
<ul>
<li><strong>特征重要性</strong></li>
<li><strong>模型预测结果总结</strong></li>
<li><strong>单个样本解释（局部）</strong></li>
<li>**what **  <strong>if</strong>  <strong>模拟</strong></li>
<li><strong>特征依赖分析（全局）</strong></li>
<li><strong>特征交互分析</strong></li>
<li><strong>树模型（针对个别模型，随机森林等）</strong></li>
</ul>
<p>需要先安装：pip install explainerdashboard</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dashboard function</span></span><br><span class="line">dashboard(bm) <span class="comment">#可以是混合的模型也可以是单个模型</span></span><br></pre></td></tr></table></figure>

<img src="images/PyCaret/image-other-dashboard.png" alt="dashboard" />

<img src="images/PyCaret/image-other-dashboard-2.png" alt="dashboard-2" style="zoom:80%;" />

<h3 id="11-6-deep-check"><a href="#11-6-deep-check" class="headerlink" title="11.6 deep_check()"></a>11.6 deep_check()</h3><p>深度检查（DeepChecks）是一个用于模型质量评估的技术和方法。它旨在帮助检测和识别机器学习模型中的问题、缺陷和偏差。通过进行全面的模型检查，可以增加对模型的可靠性、鲁棒性和可解释性的信心。</p>
<p>需要先安装：pip install deepchecks</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deep check function</span></span><br><span class="line">deep_check(bm)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-other-deep_check.png" alt="deep_check"></p>
<h3 id="11-7-eda"><a href="#11-7-eda" class="headerlink" title="11.7 eda()"></a>11.7 eda()</h3><p>在 Pycaret 中，<code>eda()</code> 函数用于进行数据探索性数据分析（Exploratory Data Analysis，简称 EDA）。该函数可以帮助用户快速了解和分析数据集的特征、分布、关联性等信息，以支持后续的数据预处理和建模工作。</p>
<p><code>eda()</code> 函数将生成一个交互式的数据探索仪表板，其中包含各种图表和可视化工具。这些图表包括数据的概览、特征分布、相关性矩阵、变量重要性等。通过这些图表，用户可以快速了解数据的特征和统计信息，并探索特征之间的关系。</p>
<p>通过使用 <code>eda()</code> 函数，可以更好地理解数据集的特点、发现异常值或缺失数据、探索特征之间的关联性，并为后续的数据预处理和建模工作提供指导。</p>
<p>需要先安装：pip install autoviz</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># eda function</span></span><br><span class="line">eda()</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-other-eda.png" alt="eda"></p>
<h3 id="11-8-create-app"><a href="#11-8-create-app" class="headerlink" title="11.8 create_app()"></a>11.8 create_app()</h3><p>在 Pycaret 中，<code>create_app()</code> 是一个用于创建交互式 Web 应用程序的函数。它可以将 Pycaret 模型和功能转换为一个具有用户界面的在线应用程序，使用户能够轻松地使用模型进行预测和分析。</p>
<p><code>create_app()</code> 函数将基于提供的模型和数据集创建一个 Web 应用程序，其中用户可以进行实时的模型预测和分析。该应用程序将在本地主机上启动一个 Web 服务器，并提供一个网页界面，用户可以在其中输入数据并获得模型的预测结果。</p>
<p>通过使用 <code>create_app()</code> 函数，可以将训练的模型快速转化为一个可用的在线应用程序，以便用户能够轻松地使用模型进行预测和分析，而无需编写额外的代码或构建独立的应用程序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create gradio app</span></span><br><span class="line">create_app(bm)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PyCaret/image-other-create_app.png" alt="create_app"></p>
<h2 id="12-参考链接"><a href="#12-参考链接" class="headerlink" title="12.参考链接"></a>12.参考链接</h2><ul>
<li><p>官网文档链接1：<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/">https://pycaret.gitbook.io/docs/</a></p>
</li>
<li><p>官网文档链接2（快速入门）：<a target="_blank" rel="noopener" href="https://pycaret.gitbook.io/docs/get-started/quickstart">https://pycaret.gitbook.io/docs/get-started/quickstart</a></p>
</li>
<li><p>官网文档链接3（回归类问题API）：<a target="_blank" rel="noopener" href="https://pycaret.readthedocs.io/en/latest/api/regression.html">https://pycaret.readthedocs.io/en/latest/api/regression.html</a></p>
</li>
<li><p>官网文档链接4（回归类问题详细教程）：<a target="_blank" rel="noopener" href="https://nbviewer.org/github/pycaret/pycaret/blob/master/tutorials/Tutorial%20-%20Regression.ipynb">https://nbviewer.org/github/pycaret/pycaret/blob/master/tutorials/Tutorial%20-%20Regression.ipynb</a></p>
</li>
<li><p>视频教程：<a target="_blank" rel="noopener" href="https://www.youtube.com/@pycaret7041/videos">https://www.youtube.com/@pycaret7041/videos</a></p>
</li>
<li><p>知乎-低代码机器学习库–Pycaret：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/412621015">https://zhuanlan.zhihu.com/p/412621015</a></p>
</li>
<li><p>知乎-PyCaret：机器学习模型开发变得简单：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/516308006">https://zhuanlan.zhihu.com/p/516308006</a></p>
</li>
<li><p>知乎-抢调包侠饭碗了！推荐一款全自动的机器学习建模神器PyCaret：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/139587526">https://zhuanlan.zhihu.com/p/139587526</a></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://dreamstar.top">dreamstar</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://dreamstar.top/2024/04/25/1.MachineLearning/AutoML/PyCaret/">http://dreamstar.top/2024/04/25/1.MachineLearning/AutoML/PyCaret/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://dreamstar.top" target="_blank">Dreamstar</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/for_post/pycaret.svg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/24/1.MachineLearning/Orange/2.orange_widget_development/2.orange_widget_development/" title="Orange 小部件开发指南"><img class="cover" src="/img/for_post/orange_illustration_landing.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Orange 小部件开发指南</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/16/0.hexo-theme/theme-github-deploy/" title="theme-hexo blog 博客的部署方式"><img class="cover" src="/img/default_cover-3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">theme-hexo blog 博客的部署方式</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dreamstar</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/arrayofstar" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:mengfan.1993@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SPWLA-group-%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="toc-text">SPWLA_group-自动机器学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pycaret%E7%AE%80%E4%BB%8B"><span class="toc-text">Pycaret简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pycaret%E5%AE%89%E8%A3%85"><span class="toc-text">Pycaret安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PyCaret%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86"><span class="toc-text">PyCaret模块划分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PyCaret%E6%A8%A1%E5%9D%97"><span class="toc-text">PyCaret模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">1. 获取数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Initialize-%E8%AE%BE%E7%BD%AEPyCaret%E7%8E%AF%E5%A2%83-setup"><span class="toc-text">2. Initialize-设置PyCaret环境-setup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86-Missing-Values"><span class="toc-text">2.1 数据准备 - 缺失值处理(Missing Values)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Data-Types"><span class="toc-text">2.2 数据准备 - 数据类型(Data Types)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-%E7%8B%AC%E7%83%AD%E7%BC%96%E7%A0%81-One-Hot-Encoding"><span class="toc-text">2.3 数据准备 - 独热编码(One-Hot Encoding)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-%E5%BA%8F%E6%95%B0%E7%BC%96%E7%A0%81-Ordinal-Encoding"><span class="toc-text">2.4 数据准备 - 序数编码(Ordinal Encoding)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-%E9%A2%84%E6%B5%8B%E7%9B%AE%E6%A0%87%E5%A4%B1%E8%A1%A1-%E7%B1%BB%E5%86%85%E4%B8%8D%E5%B9%B3%E5%9D%87-Target-Imbalance"><span class="toc-text">2.5 数据准备 - 预测目标失衡&#x2F;类内不平均(Target Imbalance)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-%E5%8E%BB%E9%99%A4%E7%A6%BB%E7%BE%A4%E5%80%BC-Remove-Outliers"><span class="toc-text">2.6 数据准备 - 去除离群值(Remove Outliers)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%E4%B8%8E%E8%BD%AC%E6%8D%A2-%E8%A7%84%E8%8C%83%E5%8C%96-%E5%BD%92%E4%B8%80%E5%8C%96-Normalize"><span class="toc-text">2.7 数据规整与转换 - 规范化&#x2F;归一化(Normalize)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%E4%B8%8E%E8%BD%AC%E6%8D%A2-%E7%89%B9%E5%BE%81%E5%8F%98%E6%8D%A2-Feature-Transform"><span class="toc-text">2.8 数据规整与转换 - 特征变换(Feature Transform)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%E4%B8%8E%E8%BD%AC%E6%8D%A2-%E7%9B%AE%E6%A0%87%E5%8F%98%E6%8D%A2-Target-Transform"><span class="toc-text">2.9 数据规整与转换 - 目标变换(Target Transform)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%89%B9%E5%BE%81-Polynomial-Features"><span class="toc-text">2.10 特征工程 - 多项式特征(Polynomial Features)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B-%E5%88%86%E7%BB%84%E7%89%B9%E5%BE%81-Group-Features"><span class="toc-text">2.11 特征工程 - 分组特征(Group Features)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B-%E5%88%86%E4%BB%93%E6%95%B0%E5%80%BC%E7%89%B9%E5%BE%81-Bin-Numeric-Features"><span class="toc-text">2.12 特征工程 - 分仓数值特征(Bin Numeric Features)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-13-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B-%E7%BB%84%E5%90%88%E7%A8%80%E6%9C%89%E5%88%86%E7%B1%BB-Combine-Rare-Levels"><span class="toc-text">2.13 特征工程 - 组合稀有分类(Combine Rare Levels)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-14-%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9-Feature-Selection"><span class="toc-text">2.14 特征选择 - Feature Selection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-15-%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9-%E5%88%A0%E9%99%A4%E5%A4%9A%E9%87%8D%E5%85%B1%E7%BA%BF%E6%80%A7%E7%89%B9%E5%BE%81-Remove-Multicollinearity"><span class="toc-text">2.15 特征选择 - 删除多重共线性特征(Remove Multicollinearity)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-16-%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90-Principal-Component-Analysis"><span class="toc-text">2.16 特征选择 - 主成分分析(Principal Component Analysis)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-17-%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9-%E5%BF%BD%E7%95%A5%E4%BD%8E%E6%96%B9%E5%B7%AE-Ignore-Low-Variance"><span class="toc-text">2.17 特征选择 - 忽略低方差(Ignore Low Variance)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-18-%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0-%E5%AE%9E%E9%AA%8C%E6%97%A5%E5%BF%97-Experiment-Logging"><span class="toc-text">2.18 其他参数 - 实验日志(Experiment Logging)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-19-%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0-%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9-Model-Selection"><span class="toc-text">2.19 其他参数 - 模型选择(Model Selection)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-20-%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0"><span class="toc-text">2.20 其他参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Train-%E6%AF%94%E8%BE%83%E6%A8%A1%E5%9E%8B-compare-models"><span class="toc-text">3. Train-比较模型-compare_models</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-N-Fold-%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81"><span class="toc-text">3.1 N-Fold 交叉验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%94%B9%E5%8F%98%E6%8E%92%E5%BA%8F%E6%A0%87%E5%87%86-Change-the-sort-order"><span class="toc-text">3.2 改变排序标准 - Change the sort order</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BB%85%E6%AF%94%E8%BE%83%E9%83%A8%E5%88%86%E6%A8%A1%E5%9E%8B-Compare-only-a-few-models-include-exclude"><span class="toc-text">3.3 仅比较部分模型 - Compare only a few models(include&#x2F;exclude)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%9C-Return-more-than-one-model-n-select"><span class="toc-text">3.4 返回多个模型结果 - Return more than one model(n_select)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%AE%BE%E5%AE%9A%E9%A2%84%E7%AE%97%E6%97%B6%E9%97%B4-Set-the-budget-time-budget-time"><span class="toc-text">3.5 设定预算时间 - Set the budget time(budget_time )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E8%AE%BE%E7%BD%AE%E6%A6%82%E7%8E%87%E9%98%88%E5%80%BC-Set-the-probability-threshold"><span class="toc-text">3.6 设置概率阈值 - Set the probability threshold</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E7%A6%81%E7%94%A8%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81-Disable-cross-validation"><span class="toc-text">3.7 禁用交叉验证 - Disable cross-validation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E6%9F%A5%E7%9C%8B%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0-Model-parameter"><span class="toc-text">3.8 查看模型参数 - Model parameter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E9%9B%86%E7%BE%A4%E4%B8%8A%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83-Distributed-training-on-a-cluster"><span class="toc-text">3.9 集群上的分布式训练 - Distributed training on a cluster</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Train-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B-create-model"><span class="toc-text">4. Train-创建模型-create_model</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%9F%A5%E7%9C%8B%E5%8F%AF%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9E%8B-Model-library"><span class="toc-text">4.1 查看可用的模型 - Model library</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%94%B9%E5%8F%98%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%8F%82%E6%95%B0"><span class="toc-text">4.2 改变模型训练参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%AE%BF%E9%97%AE%E8%AF%84%E5%88%86%E7%BD%91%E7%BB%9C-Access-the-scoring-grid"><span class="toc-text">4.3 访问评分网络 - Access the scoring grid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%A6%81%E7%94%A8%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81-Disable-cross-validation"><span class="toc-text">4.4 禁用交叉验证 - Disable cross-validation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E8%BF%94%E5%9B%9E%E8%AE%AD%E7%BB%83%E5%BE%97%E5%88%86-Return-train-score"><span class="toc-text">4.5 返回训练得分 - Return train score</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E8%AE%BE%E7%BD%AE%E6%A6%82%E7%8E%87%E9%98%88%E5%80%BC-Set-the-probability-threshold"><span class="toc-text">4.6 设置概率阈值 - Set the probability threshold</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E5%BE%AA%E7%8E%AF%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B-Train-models-in-a-loop"><span class="toc-text">4.7 循环训练模型 - Train models in a loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E8%AE%AD%E7%BB%83%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B-Train-custom-models"><span class="toc-text">4.8 训练自定义模型 - Train custom models</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A8%A1%E5%9E%8B-Write-your-own-models"><span class="toc-text">4.9 编写自己的模型 - Write your own models</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Optimize-%E8%B0%83%E6%95%B4%E6%A8%A1%E5%9E%8B-tune-model"><span class="toc-text">5. Optimize-调整模型-tune_model</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%B2%BE%E5%BA%A6%E6%8F%90%E5%8D%87"><span class="toc-text">5.1 使用方式及精度提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%A2%9E%E5%8A%A0%E8%BF%AD%E4%BB%A3-Increasing-the-iteration"><span class="toc-text">5.2 增加迭代 - Increasing the iteration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%80%89%E6%8B%A9%E5%BA%A6%E9%87%8F%E6%96%B9%E5%BC%8F-Choosing-the-metric"><span class="toc-text">5.3 选择度量方式 - Choosing the metric</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E4%BC%A0%E9%80%92%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E6%A0%BC-Passing-custom-grid"><span class="toc-text">5.4 传递自定义网格 - Passing custom grid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E6%9B%B4%E6%94%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95-Changing-the-search-algorithm"><span class="toc-text">5.5 更改搜索算法 - Changing the search algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E8%AE%BF%E9%97%AE%E5%BE%AE%E8%B0%83%E5%99%A8-Access-the-tuner"><span class="toc-text">5.6 访问微调器 - Access the tuner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E8%87%AA%E5%8A%A8%E9%80%89%E6%8B%A9%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%A8%A1%E5%9E%8B-Automatically-choose-better"><span class="toc-text">5.7 自动选择更好的模型 - Automatically choose better</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E9%9B%86%E6%88%90%E6%A8%A1%E5%9E%8B-ensemble-model"><span class="toc-text">5.8 集成模型 - ensemble_model()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bagging-%E8%A3%85%E8%A2%8B%E7%AE%97%E6%B3%95"><span class="toc-text">Bagging - 装袋算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Boosting-%E6%8F%90%E5%8D%87%E7%AE%97%E6%B3%95"><span class="toc-text">Boosting - 提升算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B-blend-models"><span class="toc-text">5.9 混合模型 - blend_models()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8A%A8%E6%80%81%E8%BE%93%E5%85%A5%E4%BC%B0%E8%AE%A1%E5%99%A8-Dynamic-input-estimators"><span class="toc-text">（1）动态输入估计器 - Dynamic input estimators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%B7%B7%E5%90%88%E6%96%B9%E6%B3%95-Changing-the-method"><span class="toc-text">（2）混合方法 - Changing the method</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%94%B9%E5%8F%98%E6%9D%83%E9%87%8D-Changing-the-weights"><span class="toc-text">（3）改变权重 - Changing the weights</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-10-%E5%A0%86%E5%8F%A0%E6%A8%A1%E5%9E%8B-stack-models"><span class="toc-text">5.10 堆叠模型 - stack_models()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-11-%E6%A0%A1%E5%87%86%E6%A8%A1%E5%9E%8B-calibrate-model"><span class="toc-text">5.11 校准模型 - calibrate_model</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Analyze-%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E7%BB%98%E5%88%B6-plot-model"><span class="toc-text">6. Analyze-模型分析与绘制-plot_model</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-plot%E7%BB%98%E5%9B%BE%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4"><span class="toc-text">6.1 plot绘图参数调整</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9B%B4%E6%94%B9%E7%BB%98%E5%9B%BE%E6%AF%94%E4%BE%8B-Change-the-scale"><span class="toc-text">（1）更改绘图比例 - Change the scale</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BF%9D%E5%AD%98%E7%BB%98%E5%9B%BE-Save-the-plot"><span class="toc-text">（2）保存绘图 - Save the plot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%9B%BE-Customize-the-plot"><span class="toc-text">（3）自定义绘图 - Customize the plot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BD%BF%E7%94%A8%E8%AE%AD%E7%BB%83%E9%9B%86%E6%95%B0%E6%8D%AE-Use-train-data"><span class="toc-text">（4）使用训练集数据 - Use train data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%8F%AF%E7%94%A8%E7%9A%84%E7%BB%98%E5%9B%BE%E7%B1%BB%E5%9E%8B-Examples-by-module"><span class="toc-text">（5）可用的绘图类型 - Examples by module</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%B1%87%E6%80%BB-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0-evaluate-model"><span class="toc-text">6.2 汇总-模型评估 - evaluate_model</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Analyze-%E8%A7%A3%E9%87%8A%E6%A8%A1%E5%9E%8B-interpret-model"><span class="toc-text">7. Analyze-解释模型-interpret_model</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%8F%AF%E8%A7%A3%E9%87%8A%E6%80%A7%E6%A8%A1%E5%9E%8B-interpret-model"><span class="toc-text">7.1 可解释性模型 - interpret_model</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BF%9D%E5%AD%98%E7%BB%98%E5%9B%BE-Save-the-plot"><span class="toc-text">（1）保存绘图 - Save the plot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BD%BF%E7%94%A8%E8%AE%AD%E7%BB%83%E9%9B%86%E6%95%B0%E6%8D%AE-Use-train-data"><span class="toc-text">（2）使用训练集数据 - Use train data</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%85%AC%E5%B9%B3%E6%80%A7%E6%A3%80%E9%AA%8C-check-fairness"><span class="toc-text">7.2 公平性检验 - check_fairness</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Deploy-%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B-predict-model"><span class="toc-text">8. Deploy-模型预测-predict_model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Deploy-%E7%A1%AE%E5%AE%9A%E6%9C%80%E7%BB%88%E6%A8%A1%E5%9E%8B-finalize-model"><span class="toc-text">9. Deploy-确定最终模型-finalize_model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Deploy-%E4%BF%9D%E5%AD%98-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B-save-load-model"><span class="toc-text">10. Deploy-保存&#x2F;加载模型-save&#x2F;load_model</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E4%BF%9D%E5%AD%98%E6%A8%A1%E5%9E%8B-save-model"><span class="toc-text">10.1 保存模型 - save_model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B-load-model"><span class="toc-text">10.2 加载模型 - load_model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E4%BF%9D%E5%AD%98%E5%AE%9E%E9%AA%8C%E8%AE%BE%E7%BD%AE-save-experiment"><span class="toc-text">10.3 保存实验设置 - save_experiment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E8%AF%BB%E5%8F%96%E5%AE%9E%E9%AA%8C%E8%AE%BE%E7%BD%AE-load-experiment"><span class="toc-text">10.4 读取实验设置 - load_experiment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0%E4%B8%8E%E8%AE%BE%E7%BD%AE"><span class="toc-text">11. 其他参数与设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-pull-%E8%BF%94%E5%9B%9E%E6%9C%80%E5%90%8E%E6%89%93%E5%8D%B0%E7%9A%84%E5%BE%97%E5%88%86%E7%BD%91%E6%A0%BC"><span class="toc-text">11.1 pull() - 返回最后打印的得分网格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-get-config-%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-text">11.2 get_config() - 获取配置信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-get-leaderboard-%E8%8E%B7%E5%8F%96%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-text">11.3 get_leaderboard() - 获取排行榜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-automl"><span class="toc-text">11.4 automl()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-dashboard"><span class="toc-text">11.5 dashboard()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-deep-check"><span class="toc-text">11.6 deep_check()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7-eda"><span class="toc-text">11.7 eda()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-8-create-app"><span class="toc-text">11.8 create_app()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">12.参考链接</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/24/1.MachineLearning/Orange/2.orange_widget_development/2.orange_widget_development/" title="Orange 小部件开发指南"><img src="/img/for_post/orange_illustration_landing.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Orange 小部件开发指南"/></a><div class="content"><a class="title" href="/2024/06/24/1.MachineLearning/Orange/2.orange_widget_development/2.orange_widget_development/" title="Orange 小部件开发指南">Orange 小部件开发指南</a><time datetime="2024-06-24T15:00:00.000Z" title="发表于 2024-06-24 23:00:00">2024-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/25/1.MachineLearning/AutoML/PyCaret/" title="PyCaret-自动机器学习框架"><img src="/img/for_post/pycaret.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PyCaret-自动机器学习框架"/></a><div class="content"><a class="title" href="/2024/04/25/1.MachineLearning/AutoML/PyCaret/" title="PyCaret-自动机器学习框架">PyCaret-自动机器学习框架</a><time datetime="2024-04-25T14:00:00.000Z" title="发表于 2024-04-25 22:00:00">2024-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/16/0.hexo-theme/theme-github-deploy/" title="theme-hexo blog 博客的部署方式"><img src="/img/default_cover-3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="theme-hexo blog 博客的部署方式"/></a><div class="content"><a class="title" href="/2024/04/16/0.hexo-theme/theme-github-deploy/" title="theme-hexo blog 博客的部署方式">theme-hexo blog 博客的部署方式</a><time datetime="2024-04-15T18:01:33.000Z" title="发表于 2024-04-16 02:01:33">2024-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/1.MachineLearning/Orange/1.orange_widget/1.orange_widget/" title="Orange widget 小部件简介"><img src="/img/for_post/orange_illustration_landing.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Orange widget 小部件简介"/></a><div class="content"><a class="title" href="/2024/03/18/1.MachineLearning/Orange/1.orange_widget/1.orange_widget/" title="Orange widget 小部件简介">Orange widget 小部件简介</a><time datetime="2024-03-18T14:00:00.000Z" title="发表于 2024-03-18 22:00:00">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/07/0.hexo-theme/theme-Butterfly/" title="hexo-theme-Butterfly"><img src="/img/default_cover-3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo-theme-Butterfly"/></a><div class="content"><a class="title" href="/2023/12/07/0.hexo-theme/theme-Butterfly/" title="hexo-theme-Butterfly">hexo-theme-Butterfly</a><time datetime="2023-12-07T14:50:53.000Z" title="发表于 2023-12-07 22:50:53">2023-12-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By dreamstar</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>